// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class Chain;
@class ChanBackupSnapshot;
@class ChanPointShim;
@class Channel;
@class ChannelBackup;
@class ChannelBackups;
@class ChannelCloseSummary;
@class ChannelCloseUpdate;
@class ChannelEdge;
@class ChannelEdgeUpdate;
@class ChannelFeeReport;
@class ChannelOpenUpdate;
@class ChannelPoint;
@class ChannelUpdate;
@class ClosedChannelUpdate;
@class EdgeLocator;
@class Failure;
@class Feature;
@class FeeLimit;
@class FloatMetric;
@class ForwardingEvent;
@class FundingPsbtFinalize;
@class FundingPsbtVerify;
@class FundingShim;
@class FundingShimCancel;
@class HTLC;
@class HTLCAttempt;
@class Hop;
@class HopHint;
@class Invoice;
@class InvoiceHTLC;
@class KeyDescriptor;
@class KeyLocator;
@class LightningAddress;
@class LightningNode;
@class MPPRecord;
@class MacaroonPermission;
@class MultiChanBackup;
@class NodeAddress;
@class NodePair;
@class NodeUpdate;
@class OutPoint;
@class Payment;
@class Peer;
@class PendingChannelsResponse_ClosedChannel;
@class PendingChannelsResponse_Commitments;
@class PendingChannelsResponse_ForceClosedChannel;
@class PendingChannelsResponse_PendingChannel;
@class PendingChannelsResponse_PendingOpenChannel;
@class PendingChannelsResponse_WaitingCloseChannel;
@class PendingHTLC;
@class PendingUpdate;
@class PsbtShim;
@class ReadyForPsbtFunding;
@class Route;
@class RouteHint;
@class RoutingPolicy;
@class TimestampedError;
@class Transaction;
@class Utxo;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum AddressType

/**
 * *
 * `AddressType` has to be one of:
 *
 * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
 * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
 **/
typedef GPB_ENUM(AddressType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  AddressType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  AddressType_WitnessPubkeyHash = 0,
  AddressType_NestedPubkeyHash = 1,
  AddressType_UnusedWitnessPubkeyHash = 2,
  AddressType_UnusedNestedPubkeyHash = 3,
};

GPBEnumDescriptor *AddressType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL AddressType_IsValidValue(int32_t value);

#pragma mark - Enum CommitmentType

typedef GPB_ENUM(CommitmentType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  CommitmentType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * *
   * A channel using the legacy commitment format having tweaked to_remote
   * keys.
   **/
  CommitmentType_Legacy = 0,

  /**
   * *
   * A channel that uses the modern commitment format where the key in the
   * output of the remote party does not change each state. This makes back
   * up and recovery easier as when the channel is closed, the funds go
   * directly to that key.
   **/
  CommitmentType_StaticRemoteKey = 1,

  /**
   * *
   * A channel that uses a commitment format that has anchor outputs on the
   * commitments, allowing fee bumping after a force close transaction has
   * been broadcast.
   **/
  CommitmentType_Anchors = 2,

  /**
   * *
   * Returned when the commitment type isn't known or unavailable.
   **/
  CommitmentType_UnknownCommitmentType = 999,
};

GPBEnumDescriptor *CommitmentType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL CommitmentType_IsValidValue(int32_t value);

#pragma mark - Enum Initiator

typedef GPB_ENUM(Initiator) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Initiator_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Initiator_InitiatorUnknown = 0,
  Initiator_InitiatorLocal = 1,
  Initiator_InitiatorRemote = 2,
  Initiator_InitiatorBoth = 3,
};

GPBEnumDescriptor *Initiator_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Initiator_IsValidValue(int32_t value);

#pragma mark - Enum NodeMetricType

typedef GPB_ENUM(NodeMetricType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  NodeMetricType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  NodeMetricType_Unknown = 0,
  NodeMetricType_BetweennessCentrality = 1,
};

GPBEnumDescriptor *NodeMetricType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL NodeMetricType_IsValidValue(int32_t value);

#pragma mark - Enum InvoiceHTLCState

typedef GPB_ENUM(InvoiceHTLCState) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  InvoiceHTLCState_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  InvoiceHTLCState_Accepted = 0,
  InvoiceHTLCState_Settled = 1,
  InvoiceHTLCState_Canceled = 2,
};

GPBEnumDescriptor *InvoiceHTLCState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL InvoiceHTLCState_IsValidValue(int32_t value);

#pragma mark - Enum PaymentFailureReason

typedef GPB_ENUM(PaymentFailureReason) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PaymentFailureReason_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * *
   * Payment isn't failed (yet).
   **/
  PaymentFailureReason_FailureReasonNone = 0,

  /**
   * *
   * There are more routes to try, but the payment timeout was exceeded.
   **/
  PaymentFailureReason_FailureReasonTimeout = 1,

  /**
   * *
   * All possible routes were tried and failed permanently. Or were no
   * routes to the destination at all.
   **/
  PaymentFailureReason_FailureReasonNoRoute = 2,

  /**
   * *
   * A non-recoverable error has occured.
   **/
  PaymentFailureReason_FailureReasonError = 3,

  /**
   * *
   * Payment details incorrect (unknown hash, invalid amt or
   * invalid final cltv delta)
   **/
  PaymentFailureReason_FailureReasonIncorrectPaymentDetails = 4,

  /**
   * *
   * Insufficient local balance.
   **/
  PaymentFailureReason_FailureReasonInsufficientBalance = 5,
};

GPBEnumDescriptor *PaymentFailureReason_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PaymentFailureReason_IsValidValue(int32_t value);

#pragma mark - Enum FeatureBit

typedef GPB_ENUM(FeatureBit) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  FeatureBit_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  FeatureBit_DatalossProtectReq = 0,
  FeatureBit_DatalossProtectOpt = 1,
  FeatureBit_InitialRouingSync = 3,
  FeatureBit_UpfrontShutdownScriptReq = 4,
  FeatureBit_UpfrontShutdownScriptOpt = 5,
  FeatureBit_GossipQueriesReq = 6,
  FeatureBit_GossipQueriesOpt = 7,
  FeatureBit_TlvOnionReq = 8,
  FeatureBit_TlvOnionOpt = 9,
  FeatureBit_ExtGossipQueriesReq = 10,
  FeatureBit_ExtGossipQueriesOpt = 11,
  FeatureBit_StaticRemoteKeyReq = 12,
  FeatureBit_StaticRemoteKeyOpt = 13,
  FeatureBit_PaymentAddrReq = 14,
  FeatureBit_PaymentAddrOpt = 15,
  FeatureBit_MppReq = 16,
  FeatureBit_MppOpt = 17,
};

GPBEnumDescriptor *FeatureBit_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FeatureBit_IsValidValue(int32_t value);

#pragma mark - Enum ChannelCloseSummary_ClosureType

typedef GPB_ENUM(ChannelCloseSummary_ClosureType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  ChannelCloseSummary_ClosureType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  ChannelCloseSummary_ClosureType_CooperativeClose = 0,
  ChannelCloseSummary_ClosureType_LocalForceClose = 1,
  ChannelCloseSummary_ClosureType_RemoteForceClose = 2,
  ChannelCloseSummary_ClosureType_BreachClose = 3,
  ChannelCloseSummary_ClosureType_FundingCanceled = 4,
  ChannelCloseSummary_ClosureType_Abandoned = 5,
};

GPBEnumDescriptor *ChannelCloseSummary_ClosureType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ChannelCloseSummary_ClosureType_IsValidValue(int32_t value);

#pragma mark - Enum Peer_SyncType

typedef GPB_ENUM(Peer_SyncType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Peer_SyncType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * *
   * Denotes that we cannot determine the peer's current sync type.
   **/
  Peer_SyncType_UnknownSync = 0,

  /**
   * *
   * Denotes that we are actively receiving new graph updates from the peer.
   **/
  Peer_SyncType_ActiveSync = 1,

  /**
   * *
   * Denotes that we are not receiving new graph updates from the peer.
   **/
  Peer_SyncType_PassiveSync = 2,
};

GPBEnumDescriptor *Peer_SyncType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Peer_SyncType_IsValidValue(int32_t value);

#pragma mark - Enum PeerEvent_EventType

typedef GPB_ENUM(PeerEvent_EventType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PeerEvent_EventType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  PeerEvent_EventType_PeerOnline = 0,
  PeerEvent_EventType_PeerOffline = 1,
};

GPBEnumDescriptor *PeerEvent_EventType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PeerEvent_EventType_IsValidValue(int32_t value);

#pragma mark - Enum PendingChannelsResponse_ForceClosedChannel_AnchorState

typedef GPB_ENUM(PendingChannelsResponse_ForceClosedChannel_AnchorState) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PendingChannelsResponse_ForceClosedChannel_AnchorState_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  PendingChannelsResponse_ForceClosedChannel_AnchorState_Limbo = 0,
  PendingChannelsResponse_ForceClosedChannel_AnchorState_Recovered = 1,
  PendingChannelsResponse_ForceClosedChannel_AnchorState_Lost = 2,
};

GPBEnumDescriptor *PendingChannelsResponse_ForceClosedChannel_AnchorState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PendingChannelsResponse_ForceClosedChannel_AnchorState_IsValidValue(int32_t value);

#pragma mark - Enum ChannelEventUpdate_UpdateType

typedef GPB_ENUM(ChannelEventUpdate_UpdateType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  ChannelEventUpdate_UpdateType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  ChannelEventUpdate_UpdateType_OpenChannel = 0,
  ChannelEventUpdate_UpdateType_ClosedChannel = 1,
  ChannelEventUpdate_UpdateType_ActiveChannel = 2,
  ChannelEventUpdate_UpdateType_InactiveChannel = 3,
  ChannelEventUpdate_UpdateType_PendingOpenChannel = 4,
};

GPBEnumDescriptor *ChannelEventUpdate_UpdateType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ChannelEventUpdate_UpdateType_IsValidValue(int32_t value);

#pragma mark - Enum Invoice_InvoiceState

typedef GPB_ENUM(Invoice_InvoiceState) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Invoice_InvoiceState_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Invoice_InvoiceState_Open = 0,
  Invoice_InvoiceState_Settled = 1,
  Invoice_InvoiceState_Canceled = 2,
  Invoice_InvoiceState_Accepted = 3,
};

GPBEnumDescriptor *Invoice_InvoiceState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Invoice_InvoiceState_IsValidValue(int32_t value);

#pragma mark - Enum Payment_PaymentStatus

typedef GPB_ENUM(Payment_PaymentStatus) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Payment_PaymentStatus_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Payment_PaymentStatus_Unknown = 0,
  Payment_PaymentStatus_InFlight = 1,
  Payment_PaymentStatus_Succeeded = 2,
  Payment_PaymentStatus_Failed = 3,
};

GPBEnumDescriptor *Payment_PaymentStatus_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Payment_PaymentStatus_IsValidValue(int32_t value);

#pragma mark - Enum HTLCAttempt_HTLCStatus

typedef GPB_ENUM(HTLCAttempt_HTLCStatus) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  HTLCAttempt_HTLCStatus_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  HTLCAttempt_HTLCStatus_InFlight = 0,
  HTLCAttempt_HTLCStatus_Succeeded = 1,
  HTLCAttempt_HTLCStatus_Failed = 2,
};

GPBEnumDescriptor *HTLCAttempt_HTLCStatus_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL HTLCAttempt_HTLCStatus_IsValidValue(int32_t value);

#pragma mark - Enum Failure_FailureCode

typedef GPB_ENUM(Failure_FailureCode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Failure_FailureCode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * *
   * The numbers assigned in this enumeration match the failure codes as
   * defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
   * a RESERVED value is added.
   **/
  Failure_FailureCode_Reserved = 0,
  Failure_FailureCode_IncorrectOrUnknownPaymentDetails = 1,
  Failure_FailureCode_IncorrectPaymentAmount = 2,
  Failure_FailureCode_FinalIncorrectCltvExpiry = 3,
  Failure_FailureCode_FinalIncorrectHtlcAmount = 4,
  Failure_FailureCode_FinalExpiryTooSoon = 5,
  Failure_FailureCode_InvalidRealm = 6,
  Failure_FailureCode_ExpiryTooSoon = 7,
  Failure_FailureCode_InvalidOnionVersion = 8,
  Failure_FailureCode_InvalidOnionHmac = 9,
  Failure_FailureCode_InvalidOnionKey = 10,
  Failure_FailureCode_AmountBelowMinimum = 11,
  Failure_FailureCode_FeeInsufficient = 12,
  Failure_FailureCode_IncorrectCltvExpiry = 13,
  Failure_FailureCode_ChannelDisabled = 14,
  Failure_FailureCode_TemporaryChannelFailure = 15,
  Failure_FailureCode_RequiredNodeFeatureMissing = 16,
  Failure_FailureCode_RequiredChannelFeatureMissing = 17,
  Failure_FailureCode_UnknownNextPeer = 18,
  Failure_FailureCode_TemporaryNodeFailure = 19,
  Failure_FailureCode_PermanentNodeFailure = 20,
  Failure_FailureCode_PermanentChannelFailure = 21,
  Failure_FailureCode_ExpiryTooFar = 22,
  Failure_FailureCode_MppTimeout = 23,

  /**
   * *
   * An internal error occurred.
   **/
  Failure_FailureCode_InternalFailure = 997,

  /**
   * *
   * The error source is known, but the failure itself couldn't be decoded.
   **/
  Failure_FailureCode_UnknownFailure = 998,

  /**
   * *
   * An unreadable failure result is returned if the received failure message
   * cannot be decrypted. In that case the error source is unknown.
   **/
  Failure_FailureCode_UnreadableFailure = 999,
};

GPBEnumDescriptor *Failure_FailureCode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Failure_FailureCode_IsValidValue(int32_t value);

#pragma mark - RpcRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface RpcRoot : GPBRootObject
@end

#pragma mark - GenSeedRequest

typedef GPB_ENUM(GenSeedRequest_FieldNumber) {
  GenSeedRequest_FieldNumber_AezeedPassphrase = 1,
  GenSeedRequest_FieldNumber_SeedEntropy = 2,
};

@interface GenSeedRequest : GPBMessage

/**
 * *
 * aezeed_passphrase is an optional user provided passphrase that will be used
 * to encrypt the generated aezeed cipher seed. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *aezeedPassphrase;

/**
 * *
 * seed_entropy is an optional 16-bytes generated via CSPRNG. If not
 * specified, then a fresh set of randomness will be used to create the seed.
 * When using REST, this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *seedEntropy;

@end

#pragma mark - GenSeedResponse

typedef GPB_ENUM(GenSeedResponse_FieldNumber) {
  GenSeedResponse_FieldNumber_CipherSeedMnemonicArray = 1,
  GenSeedResponse_FieldNumber_EncipheredSeed = 2,
};

@interface GenSeedResponse : GPBMessage

/**
 * *
 * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
 * cipher seed obtained by the user. This field is optional, as if not
 * provided, then the daemon will generate a new cipher seed for the user.
 * Otherwise, then the daemon will attempt to recover the wallet state linked
 * to this cipher seed.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *cipherSeedMnemonicArray;
/** The number of items in @c cipherSeedMnemonicArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger cipherSeedMnemonicArray_Count;

/**
 * *
 * enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
 * cipher text before run through our mnemonic encoding scheme.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *encipheredSeed;

@end

#pragma mark - InitWalletRequest

typedef GPB_ENUM(InitWalletRequest_FieldNumber) {
  InitWalletRequest_FieldNumber_WalletPassword = 1,
  InitWalletRequest_FieldNumber_CipherSeedMnemonicArray = 2,
  InitWalletRequest_FieldNumber_AezeedPassphrase = 3,
  InitWalletRequest_FieldNumber_RecoveryWindow = 4,
  InitWalletRequest_FieldNumber_ChannelBackups = 5,
};

@interface InitWalletRequest : GPBMessage

/**
 * *
 * wallet_password is the passphrase that should be used to encrypt the
 * wallet. This MUST be at least 8 chars in length. After creation, this
 * password is required to unlock the daemon. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *walletPassword;

/**
 * *
 * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
 * cipher seed obtained by the user. This may have been generated by the
 * GenSeed method, or be an existing seed.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *cipherSeedMnemonicArray;
/** The number of items in @c cipherSeedMnemonicArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger cipherSeedMnemonicArray_Count;

/**
 * *
 * aezeed_passphrase is an optional user provided passphrase that will be used
 * to encrypt the generated aezeed cipher seed. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *aezeedPassphrase;

/**
 * *
 * recovery_window is an optional argument specifying the address lookahead
 * when restoring a wallet seed. The recovery window applies to each
 * individual branch of the BIP44 derivation paths. Supplying a recovery
 * window of zero indicates that no addresses should be recovered, such after
 * the first initialization of the wallet.
 **/
@property(nonatomic, readwrite) int32_t recoveryWindow;

/**
 * *
 * channel_backups is an optional argument that allows clients to recover the
 * settled funds within a set of channels. This should be populated if the
 * user was unable to close out all channels and sweep funds before partial or
 * total data loss occurred. If specified, then after on-chain recovery of
 * funds, lnd begin to carry out the data loss recovery protocol in order to
 * recover the funds in each channel from a remote force closed transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChanBackupSnapshot *channelBackups;
/** Test to see if @c channelBackups has been set. */
@property(nonatomic, readwrite) BOOL hasChannelBackups;

@end

#pragma mark - InitWalletResponse

@interface InitWalletResponse : GPBMessage

@end

#pragma mark - UnlockWalletRequest

typedef GPB_ENUM(UnlockWalletRequest_FieldNumber) {
  UnlockWalletRequest_FieldNumber_WalletPassword = 1,
  UnlockWalletRequest_FieldNumber_RecoveryWindow = 2,
  UnlockWalletRequest_FieldNumber_ChannelBackups = 3,
};

@interface UnlockWalletRequest : GPBMessage

/**
 * *
 * wallet_password should be the current valid passphrase for the daemon. This
 * will be required to decrypt on-disk material that the daemon requires to
 * function properly. When using REST, this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *walletPassword;

/**
 * *
 * recovery_window is an optional argument specifying the address lookahead
 * when restoring a wallet seed. The recovery window applies to each
 * individual branch of the BIP44 derivation paths. Supplying a recovery
 * window of zero indicates that no addresses should be recovered, such after
 * the first initialization of the wallet.
 **/
@property(nonatomic, readwrite) int32_t recoveryWindow;

/**
 * *
 * channel_backups is an optional argument that allows clients to recover the
 * settled funds within a set of channels. This should be populated if the
 * user was unable to close out all channels and sweep funds before partial or
 * total data loss occurred. If specified, then after on-chain recovery of
 * funds, lnd begin to carry out the data loss recovery protocol in order to
 * recover the funds in each channel from a remote force closed transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChanBackupSnapshot *channelBackups;
/** Test to see if @c channelBackups has been set. */
@property(nonatomic, readwrite) BOOL hasChannelBackups;

@end

#pragma mark - UnlockWalletResponse

@interface UnlockWalletResponse : GPBMessage

@end

#pragma mark - ChangePasswordRequest

typedef GPB_ENUM(ChangePasswordRequest_FieldNumber) {
  ChangePasswordRequest_FieldNumber_CurrentPassword = 1,
  ChangePasswordRequest_FieldNumber_NewPassword = 2,
};

@interface ChangePasswordRequest : GPBMessage

/**
 * *
 * current_password should be the current valid passphrase used to unlock the
 * daemon. When using REST, this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *currentPassword;

/**
 * *
 * new_password should be the new passphrase that will be needed to unlock the
 * daemon. When using REST, this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *newPassword NS_RETURNS_NOT_RETAINED;

@end

#pragma mark - ChangePasswordResponse

@interface ChangePasswordResponse : GPBMessage

@end

#pragma mark - Utxo

typedef GPB_ENUM(Utxo_FieldNumber) {
  Utxo_FieldNumber_AddressType = 1,
  Utxo_FieldNumber_Address = 2,
  Utxo_FieldNumber_AmountSat = 3,
  Utxo_FieldNumber_PkScript = 4,
  Utxo_FieldNumber_Outpoint = 5,
  Utxo_FieldNumber_Confirmations = 6,
};

@interface Utxo : GPBMessage

/** / The type of address */
@property(nonatomic, readwrite) AddressType addressType;

/** / The address */
@property(nonatomic, readwrite, copy, null_resettable) NSString *address;

/** / The value of the unspent coin in satoshis */
@property(nonatomic, readwrite) int64_t amountSat;

/** / The pkscript in hex */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pkScript;

/** / The outpoint in format txid:n */
@property(nonatomic, readwrite, strong, null_resettable) OutPoint *outpoint;
/** Test to see if @c outpoint has been set. */
@property(nonatomic, readwrite) BOOL hasOutpoint;

/** / The number of confirmations for the Utxo */
@property(nonatomic, readwrite) int64_t confirmations;

@end

/**
 * Fetches the raw value of a @c Utxo's @c addressType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Utxo_AddressType_RawValue(Utxo *message);
/**
 * Sets the raw value of an @c Utxo's @c addressType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetUtxo_AddressType_RawValue(Utxo *message, int32_t value);

#pragma mark - Transaction

typedef GPB_ENUM(Transaction_FieldNumber) {
  Transaction_FieldNumber_TxHash = 1,
  Transaction_FieldNumber_Amount = 2,
  Transaction_FieldNumber_NumConfirmations = 3,
  Transaction_FieldNumber_BlockHash = 4,
  Transaction_FieldNumber_BlockHeight = 5,
  Transaction_FieldNumber_TimeStamp = 6,
  Transaction_FieldNumber_TotalFees = 7,
  Transaction_FieldNumber_DestAddressesArray = 8,
  Transaction_FieldNumber_RawTxHex = 9,
};

@interface Transaction : GPBMessage

/** / The transaction hash */
@property(nonatomic, readwrite, copy, null_resettable) NSString *txHash;

/** / The transaction amount, denominated in satoshis */
@property(nonatomic, readwrite) int64_t amount;

/** / The number of confirmations */
@property(nonatomic, readwrite) int32_t numConfirmations;

/** / The hash of the block this transaction was included in */
@property(nonatomic, readwrite, copy, null_resettable) NSString *blockHash;

/** / The height of the block this transaction was included in */
@property(nonatomic, readwrite) int32_t blockHeight;

/** / Timestamp of this transaction */
@property(nonatomic, readwrite) int64_t timeStamp;

/** / Fees paid for this transaction */
@property(nonatomic, readwrite) int64_t totalFees;

/** / Addresses that received funds for this transaction */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *destAddressesArray;
/** The number of items in @c destAddressesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger destAddressesArray_Count;

/** / The raw transaction hex. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *rawTxHex;

@end

#pragma mark - GetTransactionsRequest

@interface GetTransactionsRequest : GPBMessage

@end

#pragma mark - TransactionDetails

typedef GPB_ENUM(TransactionDetails_FieldNumber) {
  TransactionDetails_FieldNumber_TransactionsArray = 1,
};

@interface TransactionDetails : GPBMessage

/** / The list of transactions relevant to the wallet. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Transaction*> *transactionsArray;
/** The number of items in @c transactionsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger transactionsArray_Count;

@end

#pragma mark - FeeLimit

typedef GPB_ENUM(FeeLimit_FieldNumber) {
  FeeLimit_FieldNumber_Fixed = 1,
  FeeLimit_FieldNumber_Percent = 2,
  FeeLimit_FieldNumber_FixedMsat = 3,
};

typedef GPB_ENUM(FeeLimit_Limit_OneOfCase) {
  FeeLimit_Limit_OneOfCase_GPBUnsetOneOfCase = 0,
  FeeLimit_Limit_OneOfCase_Fixed = 1,
  FeeLimit_Limit_OneOfCase_FixedMsat = 3,
  FeeLimit_Limit_OneOfCase_Percent = 2,
};

@interface FeeLimit : GPBMessage

@property(nonatomic, readonly) FeeLimit_Limit_OneOfCase limitOneOfCase;

/**
 * *
 * The fee limit expressed as a fixed amount of satoshis.
 *
 * The fields fixed and fixed_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t fixed;

/**
 * *
 * The fee limit expressed as a fixed amount of millisatoshis.
 *
 * The fields fixed and fixed_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t fixedMsat;

/** / The fee limit expressed as a percentage of the payment amount. */
@property(nonatomic, readwrite) int64_t percent;

@end

/**
 * Clears whatever value was set for the oneof 'limit'.
 **/
void FeeLimit_ClearLimitOneOfCase(FeeLimit *message);

#pragma mark - SendRequest

typedef GPB_ENUM(SendRequest_FieldNumber) {
  SendRequest_FieldNumber_Dest = 1,
  SendRequest_FieldNumber_DestString = 2,
  SendRequest_FieldNumber_Amt = 3,
  SendRequest_FieldNumber_PaymentHash = 4,
  SendRequest_FieldNumber_PaymentHashString = 5,
  SendRequest_FieldNumber_PaymentRequest = 6,
  SendRequest_FieldNumber_FinalCltvDelta = 7,
  SendRequest_FieldNumber_FeeLimit = 8,
  SendRequest_FieldNumber_OutgoingChanId = 9,
  SendRequest_FieldNumber_CltvLimit = 10,
  SendRequest_FieldNumber_DestCustomRecords = 11,
  SendRequest_FieldNumber_AmtMsat = 12,
  SendRequest_FieldNumber_LastHopPubkey = 13,
  SendRequest_FieldNumber_AllowSelfPayment = 14,
  SendRequest_FieldNumber_DestFeaturesArray = 15,
};

@interface SendRequest : GPBMessage

/**
 * *
 * The identity pubkey of the payment recipient. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *dest;

/**
 * *
 * The hex-encoded identity pubkey of the payment recipient. Deprecated now
 * that the REST gateway supports base64 encoding of bytes fields.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *destString GPB_DEPRECATED_MSG("lnrpc.SendRequest.dest_string is deprecated (see rpc.proto).");

/**
 * *
 * The amount to send expressed in satoshis.
 *
 * The fields amt and amt_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t amt;

/**
 * *
 * The amount to send expressed in millisatoshis.
 *
 * The fields amt and amt_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t amtMsat;

/**
 * *
 * The hash to use within the payment's HTLC. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentHash;

/**
 * *
 * The hex-encoded hash to use within the payment's HTLC. Deprecated now
 * that the REST gateway supports base64 encoding of bytes fields.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentHashString GPB_DEPRECATED_MSG("lnrpc.SendRequest.payment_hash_string is deprecated (see rpc.proto).");

/**
 * *
 * A bare-bones invoice for a payment within the Lightning Network. With the
 * details of the invoice, the sender has all the data necessary to send a
 * payment to the recipient.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentRequest;

/**
 * *
 * The CLTV delta from the current height that should be used to set the
 * timelock for the final hop.
 **/
@property(nonatomic, readwrite) int32_t finalCltvDelta;

/**
 * *
 * The maximum number of satoshis that will be paid as a fee of the payment.
 * This value can be represented either as a percentage of the amount being
 * sent, or as a fixed amount of the maximum fee the user is willing the pay to
 * send the payment.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FeeLimit *feeLimit;
/** Test to see if @c feeLimit has been set. */
@property(nonatomic, readwrite) BOOL hasFeeLimit;

/**
 * *
 * The channel id of the channel that must be taken to the first hop. If zero,
 * any channel may be used.
 **/
@property(nonatomic, readwrite) uint64_t outgoingChanId;

/**
 * *
 * The pubkey of the last hop of the route. If empty, any hop may be used.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *lastHopPubkey;

/**
 * *
 * An optional maximum total time lock for the route. This should not exceed
 * lnd's `--max-cltv-expiry` setting. If zero, then the value of
 * `--max-cltv-expiry` is enforced.
 **/
@property(nonatomic, readwrite) uint32_t cltvLimit;

/**
 * *
 * An optional field that can be used to pass an arbitrary set of TLV records
 * to a peer which understands the new records. This can be used to pass
 * application specific data during the payment attempt. Record types are
 * required to be in the custom range >= 65536. When using REST, the values
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt64ObjectDictionary<NSData*> *destCustomRecords;
/** The number of items in @c destCustomRecords without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger destCustomRecords_Count;

/** / If set, circular payments to self are permitted. */
@property(nonatomic, readwrite) BOOL allowSelfPayment;

/**
 * *
 * Features assumed to be supported by the final node. All transitive feature
 * dependencies must also be set properly. For a given feature bit pair, either
 * optional or remote may be set, but not both. If this field is nil or empty,
 * the router will try to load destination features from the graph as a
 * fallback.
 **/
// |destFeaturesArray| contains |FeatureBit|
@property(nonatomic, readwrite, strong, null_resettable) GPBEnumArray *destFeaturesArray;
/** The number of items in @c destFeaturesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger destFeaturesArray_Count;

@end

#pragma mark - SendResponse

typedef GPB_ENUM(SendResponse_FieldNumber) {
  SendResponse_FieldNumber_PaymentError = 1,
  SendResponse_FieldNumber_PaymentPreimage = 2,
  SendResponse_FieldNumber_PaymentRoute = 3,
  SendResponse_FieldNumber_PaymentHash = 4,
};

@interface SendResponse : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentError;

@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentPreimage;

@property(nonatomic, readwrite, strong, null_resettable) Route *paymentRoute;
/** Test to see if @c paymentRoute has been set. */
@property(nonatomic, readwrite) BOOL hasPaymentRoute;

@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentHash;

@end

#pragma mark - SendToRouteRequest

typedef GPB_ENUM(SendToRouteRequest_FieldNumber) {
  SendToRouteRequest_FieldNumber_PaymentHash = 1,
  SendToRouteRequest_FieldNumber_PaymentHashString = 2,
  SendToRouteRequest_FieldNumber_Route = 4,
};

@interface SendToRouteRequest : GPBMessage

/**
 * *
 * The payment hash to use for the HTLC. When using REST, this field must be
 * encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentHash;

/**
 * *
 * An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
 * that the REST gateway supports base64 encoding of bytes fields.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentHashString GPB_DEPRECATED_MSG("lnrpc.SendToRouteRequest.payment_hash_string is deprecated (see rpc.proto).");

/** / Route that should be used to attempt to complete the payment. */
@property(nonatomic, readwrite, strong, null_resettable) Route *route;
/** Test to see if @c route has been set. */
@property(nonatomic, readwrite) BOOL hasRoute;

@end

#pragma mark - ChannelAcceptRequest

typedef GPB_ENUM(ChannelAcceptRequest_FieldNumber) {
  ChannelAcceptRequest_FieldNumber_NodePubkey = 1,
  ChannelAcceptRequest_FieldNumber_ChainHash = 2,
  ChannelAcceptRequest_FieldNumber_PendingChanId = 3,
  ChannelAcceptRequest_FieldNumber_FundingAmt = 4,
  ChannelAcceptRequest_FieldNumber_PushAmt = 5,
  ChannelAcceptRequest_FieldNumber_DustLimit = 6,
  ChannelAcceptRequest_FieldNumber_MaxValueInFlight = 7,
  ChannelAcceptRequest_FieldNumber_ChannelReserve = 8,
  ChannelAcceptRequest_FieldNumber_MinHtlc = 9,
  ChannelAcceptRequest_FieldNumber_FeePerKw = 10,
  ChannelAcceptRequest_FieldNumber_CsvDelay = 11,
  ChannelAcceptRequest_FieldNumber_MaxAcceptedHtlcs = 12,
  ChannelAcceptRequest_FieldNumber_ChannelFlags = 13,
};

@interface ChannelAcceptRequest : GPBMessage

/** / The pubkey of the node that wishes to open an inbound channel. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *nodePubkey;

/** / The hash of the genesis block that the proposed channel resides in. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *chainHash;

/** / The pending channel id. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

/**
 * / The funding amount in satoshis that initiator wishes to use in the
 * / channel.
 **/
@property(nonatomic, readwrite) uint64_t fundingAmt;

/** / The push amount of the proposed channel in millisatoshis. */
@property(nonatomic, readwrite) uint64_t pushAmt;

/** / The dust limit of the initiator's commitment tx. */
@property(nonatomic, readwrite) uint64_t dustLimit;

/**
 * / The maximum amount of coins in millisatoshis that can be pending in this
 * / channel.
 **/
@property(nonatomic, readwrite) uint64_t maxValueInFlight;

/**
 * / The minimum amount of satoshis the initiator requires us to have at all
 * / times.
 **/
@property(nonatomic, readwrite) uint64_t channelReserve;

/** / The smallest HTLC in millisatoshis that the initiator will accept. */
@property(nonatomic, readwrite) uint64_t minHtlc;

/**
 * / The initial fee rate that the initiator suggests for both commitment
 * / transactions.
 **/
@property(nonatomic, readwrite) uint64_t feePerKw;

/**
 * *
 * The number of blocks to use for the relative time lock in the pay-to-self
 * output of both commitment transactions.
 **/
@property(nonatomic, readwrite) uint32_t csvDelay;

/** / The total number of incoming HTLC's that the initiator will accept. */
@property(nonatomic, readwrite) uint32_t maxAcceptedHtlcs;

/**
 * / A bit-field which the initiator uses to specify proposed channel
 * / behavior.
 **/
@property(nonatomic, readwrite) uint32_t channelFlags;

@end

#pragma mark - ChannelAcceptResponse

typedef GPB_ENUM(ChannelAcceptResponse_FieldNumber) {
  ChannelAcceptResponse_FieldNumber_Accept = 1,
  ChannelAcceptResponse_FieldNumber_PendingChanId = 2,
};

@interface ChannelAcceptResponse : GPBMessage

/** / Whether or not the client accepts the channel. */
@property(nonatomic, readwrite) BOOL accept;

/** / The pending channel id to which this response applies. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

@end

#pragma mark - ChannelPoint

typedef GPB_ENUM(ChannelPoint_FieldNumber) {
  ChannelPoint_FieldNumber_FundingTxidBytes = 1,
  ChannelPoint_FieldNumber_FundingTxidStr = 2,
  ChannelPoint_FieldNumber_OutputIndex = 3,
};

typedef GPB_ENUM(ChannelPoint_FundingTxid_OneOfCase) {
  ChannelPoint_FundingTxid_OneOfCase_GPBUnsetOneOfCase = 0,
  ChannelPoint_FundingTxid_OneOfCase_FundingTxidBytes = 1,
  ChannelPoint_FundingTxid_OneOfCase_FundingTxidStr = 2,
};

@interface ChannelPoint : GPBMessage

@property(nonatomic, readonly) ChannelPoint_FundingTxid_OneOfCase fundingTxidOneOfCase;

/**
 * *
 * Txid of the funding transaction. When using REST, this field must be
 * encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *fundingTxidBytes;

/**
 * *
 * Hex-encoded string representing the byte-reversed hash of the funding
 * transaction.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *fundingTxidStr;

/** / The index of the output of the funding transaction */
@property(nonatomic, readwrite) uint32_t outputIndex;

@end

/**
 * Clears whatever value was set for the oneof 'fundingTxid'.
 **/
void ChannelPoint_ClearFundingTxidOneOfCase(ChannelPoint *message);

#pragma mark - OutPoint

typedef GPB_ENUM(OutPoint_FieldNumber) {
  OutPoint_FieldNumber_TxidBytes = 1,
  OutPoint_FieldNumber_TxidStr = 2,
  OutPoint_FieldNumber_OutputIndex = 3,
};

@interface OutPoint : GPBMessage

/** / Raw bytes representing the transaction id. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *txidBytes;

/** / Reversed, hex-encoded string representing the transaction id. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *txidStr;

/** / The index of the output on the transaction. */
@property(nonatomic, readwrite) uint32_t outputIndex;

@end

#pragma mark - LightningAddress

typedef GPB_ENUM(LightningAddress_FieldNumber) {
  LightningAddress_FieldNumber_Pubkey = 1,
  LightningAddress_FieldNumber_Host = 2,
};

@interface LightningAddress : GPBMessage

/** / The identity pubkey of the Lightning node */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubkey;

/**
 * / The network location of the lightning node, e.g. `69.69.69.69:1337` or
 * / `localhost:10011`
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *host;

@end

#pragma mark - EstimateFeeRequest

typedef GPB_ENUM(EstimateFeeRequest_FieldNumber) {
  EstimateFeeRequest_FieldNumber_AddrToAmount = 1,
  EstimateFeeRequest_FieldNumber_TargetConf = 2,
};

@interface EstimateFeeRequest : GPBMessage

/** / The map from addresses to amounts for the transaction. */
@property(nonatomic, readwrite, strong, null_resettable) GPBStringInt64Dictionary *addrToAmount;
/** The number of items in @c addrToAmount without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger addrToAmount_Count;

/**
 * / The target number of blocks that this transaction should be confirmed
 * / by.
 **/
@property(nonatomic, readwrite) int32_t targetConf;

@end

#pragma mark - EstimateFeeResponse

typedef GPB_ENUM(EstimateFeeResponse_FieldNumber) {
  EstimateFeeResponse_FieldNumber_FeeSat = 1,
  EstimateFeeResponse_FieldNumber_FeerateSatPerByte = 2,
};

@interface EstimateFeeResponse : GPBMessage

/** / The total fee in satoshis. */
@property(nonatomic, readwrite) int64_t feeSat;

/** / The fee rate in satoshi/byte. */
@property(nonatomic, readwrite) int64_t feerateSatPerByte;

@end

#pragma mark - SendManyRequest

typedef GPB_ENUM(SendManyRequest_FieldNumber) {
  SendManyRequest_FieldNumber_AddrToAmount = 1,
  SendManyRequest_FieldNumber_TargetConf = 3,
  SendManyRequest_FieldNumber_SatPerByte = 5,
};

@interface SendManyRequest : GPBMessage

/** / The map from addresses to amounts */
@property(nonatomic, readwrite, strong, null_resettable) GPBStringInt64Dictionary *addrToAmount;
/** The number of items in @c addrToAmount without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger addrToAmount_Count;

/**
 * / The target number of blocks that this transaction should be confirmed
 * / by.
 **/
@property(nonatomic, readwrite) int32_t targetConf;

/**
 * / A manual fee rate set in sat/byte that should be used when crafting the
 * / transaction.
 **/
@property(nonatomic, readwrite) int64_t satPerByte;

@end

#pragma mark - SendManyResponse

typedef GPB_ENUM(SendManyResponse_FieldNumber) {
  SendManyResponse_FieldNumber_Txid = 1,
};

@interface SendManyResponse : GPBMessage

/** / The id of the transaction */
@property(nonatomic, readwrite, copy, null_resettable) NSString *txid;

@end

#pragma mark - SendCoinsRequest

typedef GPB_ENUM(SendCoinsRequest_FieldNumber) {
  SendCoinsRequest_FieldNumber_Addr = 1,
  SendCoinsRequest_FieldNumber_Amount = 2,
  SendCoinsRequest_FieldNumber_TargetConf = 3,
  SendCoinsRequest_FieldNumber_SatPerByte = 5,
  SendCoinsRequest_FieldNumber_SendAll = 6,
};

@interface SendCoinsRequest : GPBMessage

/** / The address to send coins to */
@property(nonatomic, readwrite, copy, null_resettable) NSString *addr;

/** / The amount in satoshis to send */
@property(nonatomic, readwrite) int64_t amount;

/**
 * / The target number of blocks that this transaction should be confirmed
 * / by.
 **/
@property(nonatomic, readwrite) int32_t targetConf;

/**
 * / A manual fee rate set in sat/byte that should be used when crafting the
 * / transaction.
 **/
@property(nonatomic, readwrite) int64_t satPerByte;

/**
 * *
 * If set, then the amount field will be ignored, and lnd will attempt to
 * send all the coins under control of the internal wallet to the specified
 * address.
 **/
@property(nonatomic, readwrite) BOOL sendAll;

@end

#pragma mark - SendCoinsResponse

typedef GPB_ENUM(SendCoinsResponse_FieldNumber) {
  SendCoinsResponse_FieldNumber_Txid = 1,
};

@interface SendCoinsResponse : GPBMessage

/** / The transaction ID of the transaction */
@property(nonatomic, readwrite, copy, null_resettable) NSString *txid;

@end

#pragma mark - ListUnspentRequest

typedef GPB_ENUM(ListUnspentRequest_FieldNumber) {
  ListUnspentRequest_FieldNumber_MinConfs = 1,
  ListUnspentRequest_FieldNumber_MaxConfs = 2,
};

@interface ListUnspentRequest : GPBMessage

/** / The minimum number of confirmations to be included. */
@property(nonatomic, readwrite) int32_t minConfs;

/** / The maximum number of confirmations to be included. */
@property(nonatomic, readwrite) int32_t maxConfs;

@end

#pragma mark - ListUnspentResponse

typedef GPB_ENUM(ListUnspentResponse_FieldNumber) {
  ListUnspentResponse_FieldNumber_UtxosArray = 1,
};

@interface ListUnspentResponse : GPBMessage

/** / A list of utxos */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Utxo*> *utxosArray;
/** The number of items in @c utxosArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger utxosArray_Count;

@end

#pragma mark - NewAddressRequest

typedef GPB_ENUM(NewAddressRequest_FieldNumber) {
  NewAddressRequest_FieldNumber_Type = 1,
};

@interface NewAddressRequest : GPBMessage

/** / The address type */
@property(nonatomic, readwrite) AddressType type;

@end

/**
 * Fetches the raw value of a @c NewAddressRequest's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t NewAddressRequest_Type_RawValue(NewAddressRequest *message);
/**
 * Sets the raw value of an @c NewAddressRequest's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetNewAddressRequest_Type_RawValue(NewAddressRequest *message, int32_t value);

#pragma mark - NewAddressResponse

typedef GPB_ENUM(NewAddressResponse_FieldNumber) {
  NewAddressResponse_FieldNumber_Address = 1,
};

@interface NewAddressResponse : GPBMessage

/** / The newly generated wallet address */
@property(nonatomic, readwrite, copy, null_resettable) NSString *address;

@end

#pragma mark - SignMessageRequest

typedef GPB_ENUM(SignMessageRequest_FieldNumber) {
  SignMessageRequest_FieldNumber_Msg = 1,
};

@interface SignMessageRequest : GPBMessage

/**
 * *
 * The message to be signed. When using REST, this field must be encoded as
 * base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *msg;

@end

#pragma mark - SignMessageResponse

typedef GPB_ENUM(SignMessageResponse_FieldNumber) {
  SignMessageResponse_FieldNumber_Signature = 1,
};

@interface SignMessageResponse : GPBMessage

/** / The signature for the given message */
@property(nonatomic, readwrite, copy, null_resettable) NSString *signature;

@end

#pragma mark - VerifyMessageRequest

typedef GPB_ENUM(VerifyMessageRequest_FieldNumber) {
  VerifyMessageRequest_FieldNumber_Msg = 1,
  VerifyMessageRequest_FieldNumber_Signature = 2,
};

@interface VerifyMessageRequest : GPBMessage

/**
 * *
 * The message over which the signature is to be verified. When using REST,
 * this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *msg;

/** / The signature to be verified over the given message */
@property(nonatomic, readwrite, copy, null_resettable) NSString *signature;

@end

#pragma mark - VerifyMessageResponse

typedef GPB_ENUM(VerifyMessageResponse_FieldNumber) {
  VerifyMessageResponse_FieldNumber_Valid = 1,
  VerifyMessageResponse_FieldNumber_Pubkey = 2,
};

@interface VerifyMessageResponse : GPBMessage

/** / Whether the signature was valid over the given message */
@property(nonatomic, readwrite) BOOL valid;

/** / The pubkey recovered from the signature */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubkey;

@end

#pragma mark - ConnectPeerRequest

typedef GPB_ENUM(ConnectPeerRequest_FieldNumber) {
  ConnectPeerRequest_FieldNumber_Addr = 1,
  ConnectPeerRequest_FieldNumber_Perm = 2,
};

@interface ConnectPeerRequest : GPBMessage

/** / Lightning address of the peer, in the format `<pubkey>\@host` */
@property(nonatomic, readwrite, strong, null_resettable) LightningAddress *addr;
/** Test to see if @c addr has been set. */
@property(nonatomic, readwrite) BOOL hasAddr;

/**
 * * If set, the daemon will attempt to persistently connect to the target
 * peer. Otherwise, the call will be synchronous.
 **/
@property(nonatomic, readwrite) BOOL perm;

@end

#pragma mark - ConnectPeerResponse

@interface ConnectPeerResponse : GPBMessage

@end

#pragma mark - DisconnectPeerRequest

typedef GPB_ENUM(DisconnectPeerRequest_FieldNumber) {
  DisconnectPeerRequest_FieldNumber_PubKey = 1,
};

@interface DisconnectPeerRequest : GPBMessage

/** / The pubkey of the node to disconnect from */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

@end

#pragma mark - DisconnectPeerResponse

@interface DisconnectPeerResponse : GPBMessage

@end

#pragma mark - HTLC

typedef GPB_ENUM(HTLC_FieldNumber) {
  HTLC_FieldNumber_Incoming = 1,
  HTLC_FieldNumber_Amount = 2,
  HTLC_FieldNumber_HashLock = 3,
  HTLC_FieldNumber_ExpirationHeight = 4,
};

@interface HTLC : GPBMessage

@property(nonatomic, readwrite) BOOL incoming;

@property(nonatomic, readwrite) int64_t amount;

@property(nonatomic, readwrite, copy, null_resettable) NSData *hashLock;

@property(nonatomic, readwrite) uint32_t expirationHeight;

@end

#pragma mark - Channel

typedef GPB_ENUM(Channel_FieldNumber) {
  Channel_FieldNumber_Active = 1,
  Channel_FieldNumber_RemotePubkey = 2,
  Channel_FieldNumber_ChannelPoint = 3,
  Channel_FieldNumber_ChanId = 4,
  Channel_FieldNumber_Capacity = 5,
  Channel_FieldNumber_LocalBalance = 6,
  Channel_FieldNumber_RemoteBalance = 7,
  Channel_FieldNumber_CommitFee = 8,
  Channel_FieldNumber_CommitWeight = 9,
  Channel_FieldNumber_FeePerKw = 10,
  Channel_FieldNumber_UnsettledBalance = 11,
  Channel_FieldNumber_TotalSatoshisSent = 12,
  Channel_FieldNumber_TotalSatoshisReceived = 13,
  Channel_FieldNumber_NumUpdates = 14,
  Channel_FieldNumber_PendingHtlcsArray = 15,
  Channel_FieldNumber_CsvDelay = 16,
  Channel_FieldNumber_Private_p = 17,
  Channel_FieldNumber_Initiator = 18,
  Channel_FieldNumber_ChanStatusFlags = 19,
  Channel_FieldNumber_LocalChanReserveSat = 20,
  Channel_FieldNumber_RemoteChanReserveSat = 21,
  Channel_FieldNumber_StaticRemoteKey = 22,
  Channel_FieldNumber_Lifetime = 23,
  Channel_FieldNumber_Uptime = 24,
  Channel_FieldNumber_CloseAddress = 25,
  Channel_FieldNumber_CommitmentType = 26,
  Channel_FieldNumber_PushAmountSat = 27,
  Channel_FieldNumber_ThawHeight = 28,
};

@interface Channel : GPBMessage

/** / Whether this channel is active or not */
@property(nonatomic, readwrite) BOOL active;

/** / The identity pubkey of the remote node */
@property(nonatomic, readwrite, copy, null_resettable) NSString *remotePubkey;

/**
 * *
 * The outpoint (txid:index) of the funding transaction. With this value, Bob
 * will be able to generate a signature for Alice's version of the commitment
 * transaction.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelPoint;

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

/** / The total amount of funds held in this channel */
@property(nonatomic, readwrite) int64_t capacity;

/** / This node's current balance in this channel */
@property(nonatomic, readwrite) int64_t localBalance;

/** / The counterparty's current balance in this channel */
@property(nonatomic, readwrite) int64_t remoteBalance;

/**
 * *
 * The amount calculated to be paid in fees for the current set of commitment
 * transactions. The fee amount is persisted with the channel in order to
 * allow the fee amount to be removed and recalculated with each channel state
 * update, including updates that happen after a system restart.
 **/
@property(nonatomic, readwrite) int64_t commitFee;

/** / The weight of the commitment transaction */
@property(nonatomic, readwrite) int64_t commitWeight;

/**
 * *
 * The required number of satoshis per kilo-weight that the requester will pay
 * at all times, for both the funding transaction and commitment transaction.
 * This value can later be updated once the channel is open.
 **/
@property(nonatomic, readwrite) int64_t feePerKw;

/** / The unsettled balance in this channel */
@property(nonatomic, readwrite) int64_t unsettledBalance;

/**
 * *
 * The total number of satoshis we've sent within this channel.
 **/
@property(nonatomic, readwrite) int64_t totalSatoshisSent;

/**
 * *
 * The total number of satoshis we've received within this channel.
 **/
@property(nonatomic, readwrite) int64_t totalSatoshisReceived;

/**
 * *
 * The total number of updates conducted within this channel.
 **/
@property(nonatomic, readwrite) uint64_t numUpdates;

/**
 * *
 * The list of active, uncleared HTLCs currently pending within the channel.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<HTLC*> *pendingHtlcsArray;
/** The number of items in @c pendingHtlcsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger pendingHtlcsArray_Count;

/**
 * *
 * The CSV delay expressed in relative blocks. If the channel is force closed,
 * we will need to wait for this many blocks before we can regain our funds.
 **/
@property(nonatomic, readwrite) uint32_t csvDelay;

/** / Whether this channel is advertised to the network or not. */
@property(nonatomic, readwrite) BOOL private_p;

/** / True if we were the ones that created the channel. */
@property(nonatomic, readwrite) BOOL initiator;

/** / A set of flags showing the current state of the channel. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *chanStatusFlags;

/** / The minimum satoshis this node is required to reserve in its balance. */
@property(nonatomic, readwrite) int64_t localChanReserveSat;

/**
 * *
 * The minimum satoshis the other node is required to reserve in its balance.
 **/
@property(nonatomic, readwrite) int64_t remoteChanReserveSat;

/** / Deprecated. Use commitment_type. */
@property(nonatomic, readwrite) BOOL staticRemoteKey GPB_DEPRECATED_MSG("lnrpc.Channel.static_remote_key is deprecated (see rpc.proto).");

/** / The commitment type used by this channel. */
@property(nonatomic, readwrite) CommitmentType commitmentType;

/**
 * *
 * The number of seconds that the channel has been monitored by the channel
 * scoring system. Scores are currently not persisted, so this value may be
 * less than the lifetime of the channel [EXPERIMENTAL].
 **/
@property(nonatomic, readwrite) int64_t lifetime;

/**
 * *
 * The number of seconds that the remote peer has been observed as being online
 * by the channel scoring system over the lifetime of the channel
 * [EXPERIMENTAL].
 **/
@property(nonatomic, readwrite) int64_t uptime;

/**
 * *
 * Close address is the address that we will enforce payout to on cooperative
 * close if the channel was opened utilizing option upfront shutdown. This
 * value can be set on channel open by setting close_address in an open channel
 * request. If this value is not set, you can still choose a payout address by
 * cooperatively closing with the delivery_address field set.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *closeAddress;

/**
 *
 * The amount that the initiator of the channel optionally pushed to the remote
 * party on channel open. This amount will be zero if the channel initiator did
 * not push any funds to the remote peer. If the initiator field is true, we
 * pushed this amount to our peer, if it is false, the remote peer pushed this
 * amount to us.
 **/
@property(nonatomic, readwrite) uint64_t pushAmountSat;

/**
 * *
 * This uint32 indicates if this channel is to be considered 'frozen'. A
 * frozen channel doest not allow a cooperative channel close by the
 * initiator. The thaw_height is the height that this restriction stops
 * applying to the channel. This field is optional, not setting it or using a
 * value of zero will mean the channel has no additional restrictions.
 **/
@property(nonatomic, readwrite) uint32_t thawHeight;

@end

/**
 * Fetches the raw value of a @c Channel's @c commitmentType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Channel_CommitmentType_RawValue(Channel *message);
/**
 * Sets the raw value of an @c Channel's @c commitmentType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannel_CommitmentType_RawValue(Channel *message, int32_t value);

#pragma mark - ListChannelsRequest

typedef GPB_ENUM(ListChannelsRequest_FieldNumber) {
  ListChannelsRequest_FieldNumber_ActiveOnly = 1,
  ListChannelsRequest_FieldNumber_InactiveOnly = 2,
  ListChannelsRequest_FieldNumber_PublicOnly = 3,
  ListChannelsRequest_FieldNumber_PrivateOnly = 4,
  ListChannelsRequest_FieldNumber_Peer = 5,
};

@interface ListChannelsRequest : GPBMessage

@property(nonatomic, readwrite) BOOL activeOnly;

@property(nonatomic, readwrite) BOOL inactiveOnly;

@property(nonatomic, readwrite) BOOL publicOnly;

@property(nonatomic, readwrite) BOOL privateOnly;

/**
 * *
 * Filters the response for channels with a target peer's pubkey. If peer is
 * empty, all channels will be returned.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *peer;

@end

#pragma mark - ListChannelsResponse

typedef GPB_ENUM(ListChannelsResponse_FieldNumber) {
  ListChannelsResponse_FieldNumber_ChannelsArray = 11,
};

@interface ListChannelsResponse : GPBMessage

/** / The list of active channels */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Channel*> *channelsArray;
/** The number of items in @c channelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger channelsArray_Count;

@end

#pragma mark - ChannelCloseSummary

typedef GPB_ENUM(ChannelCloseSummary_FieldNumber) {
  ChannelCloseSummary_FieldNumber_ChannelPoint = 1,
  ChannelCloseSummary_FieldNumber_ChanId = 2,
  ChannelCloseSummary_FieldNumber_ChainHash = 3,
  ChannelCloseSummary_FieldNumber_ClosingTxHash = 4,
  ChannelCloseSummary_FieldNumber_RemotePubkey = 5,
  ChannelCloseSummary_FieldNumber_Capacity = 6,
  ChannelCloseSummary_FieldNumber_CloseHeight = 7,
  ChannelCloseSummary_FieldNumber_SettledBalance = 8,
  ChannelCloseSummary_FieldNumber_TimeLockedBalance = 9,
  ChannelCloseSummary_FieldNumber_CloseType = 10,
  ChannelCloseSummary_FieldNumber_OpenInitiator = 11,
  ChannelCloseSummary_FieldNumber_CloseInitiator = 12,
};

@interface ChannelCloseSummary : GPBMessage

/** / The outpoint (txid:index) of the funding transaction. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelPoint;

/** /  The unique channel ID for the channel. */
@property(nonatomic, readwrite) uint64_t chanId;

/** / The hash of the genesis block that this channel resides within. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *chainHash;

/** / The txid of the transaction which ultimately closed this channel. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *closingTxHash;

/** / Public key of the remote peer that we formerly had a channel with. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *remotePubkey;

/** / Total capacity of the channel. */
@property(nonatomic, readwrite) int64_t capacity;

/** / Height at which the funding transaction was spent. */
@property(nonatomic, readwrite) uint32_t closeHeight;

/** / Settled balance at the time of channel closure */
@property(nonatomic, readwrite) int64_t settledBalance;

/** / The sum of all the time-locked outputs at the time of channel closure */
@property(nonatomic, readwrite) int64_t timeLockedBalance;

/** / Details on how the channel was closed. */
@property(nonatomic, readwrite) ChannelCloseSummary_ClosureType closeType;

/**
 * *
 * Open initiator is the party that initiated opening the channel. Note that
 * this value may be unknown if the channel was closed before we migrated to
 * store open channel information after close.
 **/
@property(nonatomic, readwrite) Initiator openInitiator;

/**
 * *
 * Close initiator indicates which party initiated the close. This value will
 * be unknown for channels that were cooperatively closed before we started
 * tracking cooperative close initiators. Note that this indicates which party
 * initiated a close, and it is possible for both to initiate cooperative or
 * force closes, although only one party's close will be confirmed on chain.
 **/
@property(nonatomic, readwrite) Initiator closeInitiator;

@end

/**
 * Fetches the raw value of a @c ChannelCloseSummary's @c closeType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t ChannelCloseSummary_CloseType_RawValue(ChannelCloseSummary *message);
/**
 * Sets the raw value of an @c ChannelCloseSummary's @c closeType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannelCloseSummary_CloseType_RawValue(ChannelCloseSummary *message, int32_t value);

/**
 * Fetches the raw value of a @c ChannelCloseSummary's @c openInitiator property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t ChannelCloseSummary_OpenInitiator_RawValue(ChannelCloseSummary *message);
/**
 * Sets the raw value of an @c ChannelCloseSummary's @c openInitiator property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannelCloseSummary_OpenInitiator_RawValue(ChannelCloseSummary *message, int32_t value);

/**
 * Fetches the raw value of a @c ChannelCloseSummary's @c closeInitiator property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t ChannelCloseSummary_CloseInitiator_RawValue(ChannelCloseSummary *message);
/**
 * Sets the raw value of an @c ChannelCloseSummary's @c closeInitiator property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannelCloseSummary_CloseInitiator_RawValue(ChannelCloseSummary *message, int32_t value);

#pragma mark - ClosedChannelsRequest

typedef GPB_ENUM(ClosedChannelsRequest_FieldNumber) {
  ClosedChannelsRequest_FieldNumber_Cooperative = 1,
  ClosedChannelsRequest_FieldNumber_LocalForce = 2,
  ClosedChannelsRequest_FieldNumber_RemoteForce = 3,
  ClosedChannelsRequest_FieldNumber_Breach = 4,
  ClosedChannelsRequest_FieldNumber_FundingCanceled = 5,
  ClosedChannelsRequest_FieldNumber_Abandoned = 6,
};

@interface ClosedChannelsRequest : GPBMessage

@property(nonatomic, readwrite) BOOL cooperative;

@property(nonatomic, readwrite) BOOL localForce;

@property(nonatomic, readwrite) BOOL remoteForce;

@property(nonatomic, readwrite) BOOL breach;

@property(nonatomic, readwrite) BOOL fundingCanceled;

@property(nonatomic, readwrite) BOOL abandoned;

@end

#pragma mark - ClosedChannelsResponse

typedef GPB_ENUM(ClosedChannelsResponse_FieldNumber) {
  ClosedChannelsResponse_FieldNumber_ChannelsArray = 1,
};

@interface ClosedChannelsResponse : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelCloseSummary*> *channelsArray;
/** The number of items in @c channelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger channelsArray_Count;

@end

#pragma mark - Peer

typedef GPB_ENUM(Peer_FieldNumber) {
  Peer_FieldNumber_PubKey = 1,
  Peer_FieldNumber_Address = 3,
  Peer_FieldNumber_BytesSent = 4,
  Peer_FieldNumber_BytesRecv = 5,
  Peer_FieldNumber_SatSent = 6,
  Peer_FieldNumber_SatRecv = 7,
  Peer_FieldNumber_Inbound = 8,
  Peer_FieldNumber_PingTime = 9,
  Peer_FieldNumber_SyncType = 10,
  Peer_FieldNumber_Features = 11,
  Peer_FieldNumber_ErrorsArray = 12,
};

@interface Peer : GPBMessage

/** / The identity pubkey of the peer */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

/** / Network address of the peer; eg `127.0.0.1:10011` */
@property(nonatomic, readwrite, copy, null_resettable) NSString *address;

/** / Bytes of data transmitted to this peer */
@property(nonatomic, readwrite) uint64_t bytesSent;

/** / Bytes of data transmitted from this peer */
@property(nonatomic, readwrite) uint64_t bytesRecv;

/** / Satoshis sent to this peer */
@property(nonatomic, readwrite) int64_t satSent;

/** / Satoshis received from this peer */
@property(nonatomic, readwrite) int64_t satRecv;

/** / A channel is inbound if the counterparty initiated the channel */
@property(nonatomic, readwrite) BOOL inbound;

/** / Ping time to this peer */
@property(nonatomic, readwrite) int64_t pingTime;

/** The type of sync we are currently performing with this peer. */
@property(nonatomic, readwrite) Peer_SyncType syncType;

/** / Features advertised by the remote peer in their init message. */
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32ObjectDictionary<Feature*> *features;
/** The number of items in @c features without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger features_Count;

/**
 *
 * The latest errors received from our peer with timestamps, limited to the 10
 * most recent errors. These errors are tracked across peer connections, but
 * are not persisted across lnd restarts. Note that these errors are only
 * stored for peers that we have channels open with, to prevent peers from
 * spamming us with errors at no cost.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<TimestampedError*> *errorsArray;
/** The number of items in @c errorsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger errorsArray_Count;

@end

/**
 * Fetches the raw value of a @c Peer's @c syncType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Peer_SyncType_RawValue(Peer *message);
/**
 * Sets the raw value of an @c Peer's @c syncType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPeer_SyncType_RawValue(Peer *message, int32_t value);

#pragma mark - TimestampedError

typedef GPB_ENUM(TimestampedError_FieldNumber) {
  TimestampedError_FieldNumber_Timestamp = 1,
  TimestampedError_FieldNumber_Error = 2,
};

@interface TimestampedError : GPBMessage

/** The unix timestamp in seconds when the error occurred. */
@property(nonatomic, readwrite) uint64_t timestamp;

/** The string representation of the error sent by our peer. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *error;

@end

#pragma mark - ListPeersRequest

typedef GPB_ENUM(ListPeersRequest_FieldNumber) {
  ListPeersRequest_FieldNumber_LatestError = 1,
};

@interface ListPeersRequest : GPBMessage

/**
 *
 * If true, only the last error that our peer sent us will be returned with
 * the peer's information, rather than the full set of historic errors we have
 * stored.
 **/
@property(nonatomic, readwrite) BOOL latestError;

@end

#pragma mark - ListPeersResponse

typedef GPB_ENUM(ListPeersResponse_FieldNumber) {
  ListPeersResponse_FieldNumber_PeersArray = 1,
};

@interface ListPeersResponse : GPBMessage

/** / The list of currently connected peers */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Peer*> *peersArray;
/** The number of items in @c peersArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger peersArray_Count;

@end

#pragma mark - PeerEventSubscription

@interface PeerEventSubscription : GPBMessage

@end

#pragma mark - PeerEvent

typedef GPB_ENUM(PeerEvent_FieldNumber) {
  PeerEvent_FieldNumber_PubKey = 1,
  PeerEvent_FieldNumber_Type = 2,
};

@interface PeerEvent : GPBMessage

/** / The identity pubkey of the peer. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

@property(nonatomic, readwrite) PeerEvent_EventType type;

@end

/**
 * Fetches the raw value of a @c PeerEvent's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PeerEvent_Type_RawValue(PeerEvent *message);
/**
 * Sets the raw value of an @c PeerEvent's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPeerEvent_Type_RawValue(PeerEvent *message, int32_t value);

#pragma mark - GetInfoRequest

@interface GetInfoRequest : GPBMessage

@end

#pragma mark - GetInfoResponse

typedef GPB_ENUM(GetInfoResponse_FieldNumber) {
  GetInfoResponse_FieldNumber_IdentityPubkey = 1,
  GetInfoResponse_FieldNumber_Alias = 2,
  GetInfoResponse_FieldNumber_NumPendingChannels = 3,
  GetInfoResponse_FieldNumber_NumActiveChannels = 4,
  GetInfoResponse_FieldNumber_NumPeers = 5,
  GetInfoResponse_FieldNumber_BlockHeight = 6,
  GetInfoResponse_FieldNumber_BlockHash = 8,
  GetInfoResponse_FieldNumber_SyncedToChain = 9,
  GetInfoResponse_FieldNumber_Testnet = 10,
  GetInfoResponse_FieldNumber_UrisArray = 12,
  GetInfoResponse_FieldNumber_BestHeaderTimestamp = 13,
  GetInfoResponse_FieldNumber_Version = 14,
  GetInfoResponse_FieldNumber_NumInactiveChannels = 15,
  GetInfoResponse_FieldNumber_ChainsArray = 16,
  GetInfoResponse_FieldNumber_Color = 17,
  GetInfoResponse_FieldNumber_SyncedToGraph = 18,
  GetInfoResponse_FieldNumber_Features = 19,
  GetInfoResponse_FieldNumber_CommitHash = 20,
};

@interface GetInfoResponse : GPBMessage

/** / The version of the LND software that the node is running. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *version;

/** / The SHA1 commit hash that the daemon is compiled with. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *commitHash;

/** / The identity pubkey of the current node. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *identityPubkey;

/** / If applicable, the alias of the current node, e.g. "bob" */
@property(nonatomic, readwrite, copy, null_resettable) NSString *alias;

/** / The color of the current node in hex code format */
@property(nonatomic, readwrite, copy, null_resettable) NSString *color;

/** / Number of pending channels */
@property(nonatomic, readwrite) uint32_t numPendingChannels;

/** / Number of active channels */
@property(nonatomic, readwrite) uint32_t numActiveChannels;

/** / Number of inactive channels */
@property(nonatomic, readwrite) uint32_t numInactiveChannels;

/** / Number of peers */
@property(nonatomic, readwrite) uint32_t numPeers;

/** / The node's current view of the height of the best block */
@property(nonatomic, readwrite) uint32_t blockHeight;

/** / The node's current view of the hash of the best block */
@property(nonatomic, readwrite, copy, null_resettable) NSString *blockHash;

/** / Timestamp of the block best known to the wallet */
@property(nonatomic, readwrite) int64_t bestHeaderTimestamp;

/** / Whether the wallet's view is synced to the main chain */
@property(nonatomic, readwrite) BOOL syncedToChain;

/** Whether we consider ourselves synced with the public channel graph. */
@property(nonatomic, readwrite) BOOL syncedToGraph;

/**
 * *
 * Whether the current node is connected to testnet. This field is
 * deprecated and the network field should be used instead
 **/
@property(nonatomic, readwrite) BOOL testnet GPB_DEPRECATED_MSG("lnrpc.GetInfoResponse.testnet is deprecated (see rpc.proto).");

/** / A list of active chains the node is connected to */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Chain*> *chainsArray;
/** The number of items in @c chainsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger chainsArray_Count;

/** / The URIs of the current node. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *urisArray;
/** The number of items in @c urisArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger urisArray_Count;

/**
 *
 * Features that our node has advertised in our init message, node
 * announcements and invoices.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32ObjectDictionary<Feature*> *features;
/** The number of items in @c features without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger features_Count;

@end

#pragma mark - Chain

typedef GPB_ENUM(Chain_FieldNumber) {
  Chain_FieldNumber_Chain = 1,
  Chain_FieldNumber_Network = 2,
};

@interface Chain : GPBMessage

/** / The blockchain the node is on (eg bitcoin, litecoin) */
@property(nonatomic, readwrite, copy, null_resettable) NSString *chain;

/** / The network the node is on (eg regtest, testnet, mainnet) */
@property(nonatomic, readwrite, copy, null_resettable) NSString *network;

@end

#pragma mark - ConfirmationUpdate

typedef GPB_ENUM(ConfirmationUpdate_FieldNumber) {
  ConfirmationUpdate_FieldNumber_BlockSha = 1,
  ConfirmationUpdate_FieldNumber_BlockHeight = 2,
  ConfirmationUpdate_FieldNumber_NumConfsLeft = 3,
};

@interface ConfirmationUpdate : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *blockSha;

@property(nonatomic, readwrite) int32_t blockHeight;

@property(nonatomic, readwrite) uint32_t numConfsLeft;

@end

#pragma mark - ChannelOpenUpdate

typedef GPB_ENUM(ChannelOpenUpdate_FieldNumber) {
  ChannelOpenUpdate_FieldNumber_ChannelPoint = 1,
};

@interface ChannelOpenUpdate : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *channelPoint;
/** Test to see if @c channelPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChannelPoint;

@end

#pragma mark - ChannelCloseUpdate

typedef GPB_ENUM(ChannelCloseUpdate_FieldNumber) {
  ChannelCloseUpdate_FieldNumber_ClosingTxid = 1,
  ChannelCloseUpdate_FieldNumber_Success = 2,
};

@interface ChannelCloseUpdate : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *closingTxid;

@property(nonatomic, readwrite) BOOL success;

@end

#pragma mark - CloseChannelRequest

typedef GPB_ENUM(CloseChannelRequest_FieldNumber) {
  CloseChannelRequest_FieldNumber_ChannelPoint = 1,
  CloseChannelRequest_FieldNumber_Force = 2,
  CloseChannelRequest_FieldNumber_TargetConf = 3,
  CloseChannelRequest_FieldNumber_SatPerByte = 4,
  CloseChannelRequest_FieldNumber_DeliveryAddress = 5,
};

@interface CloseChannelRequest : GPBMessage

/**
 * *
 * The outpoint (txid:index) of the funding transaction. With this value, Bob
 * will be able to generate a signature for Alice's version of the commitment
 * transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *channelPoint;
/** Test to see if @c channelPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChannelPoint;

/**
 * / If true, then the channel will be closed forcibly. This means the
 * / current commitment transaction will be signed and broadcast.
 **/
@property(nonatomic, readwrite) BOOL force;

/**
 * / The target number of blocks that the closure transaction should be
 * / confirmed by.
 **/
@property(nonatomic, readwrite) int32_t targetConf;

/**
 * / A manual fee rate set in sat/byte that should be used when crafting the
 * / closure transaction.
 **/
@property(nonatomic, readwrite) int64_t satPerByte;

/**
 *
 * An optional address to send funds to in the case of a cooperative close.
 * If the channel was opened with an upfront shutdown script and this field
 * is set, the request to close will fail because the channel must pay out
 * to the upfront shutdown addresss.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *deliveryAddress;

@end

#pragma mark - CloseStatusUpdate

typedef GPB_ENUM(CloseStatusUpdate_FieldNumber) {
  CloseStatusUpdate_FieldNumber_ClosePending = 1,
  CloseStatusUpdate_FieldNumber_ChanClose = 3,
};

typedef GPB_ENUM(CloseStatusUpdate_Update_OneOfCase) {
  CloseStatusUpdate_Update_OneOfCase_GPBUnsetOneOfCase = 0,
  CloseStatusUpdate_Update_OneOfCase_ClosePending = 1,
  CloseStatusUpdate_Update_OneOfCase_ChanClose = 3,
};

@interface CloseStatusUpdate : GPBMessage

@property(nonatomic, readonly) CloseStatusUpdate_Update_OneOfCase updateOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) PendingUpdate *closePending;

@property(nonatomic, readwrite, strong, null_resettable) ChannelCloseUpdate *chanClose;

@end

/**
 * Clears whatever value was set for the oneof 'update'.
 **/
void CloseStatusUpdate_ClearUpdateOneOfCase(CloseStatusUpdate *message);

#pragma mark - PendingUpdate

typedef GPB_ENUM(PendingUpdate_FieldNumber) {
  PendingUpdate_FieldNumber_Txid = 1,
  PendingUpdate_FieldNumber_OutputIndex = 2,
};

@interface PendingUpdate : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *txid;

@property(nonatomic, readwrite) uint32_t outputIndex;

@end

#pragma mark - ReadyForPsbtFunding

typedef GPB_ENUM(ReadyForPsbtFunding_FieldNumber) {
  ReadyForPsbtFunding_FieldNumber_FundingAddress = 1,
  ReadyForPsbtFunding_FieldNumber_FundingAmount = 2,
  ReadyForPsbtFunding_FieldNumber_Psbt = 3,
};

@interface ReadyForPsbtFunding : GPBMessage

/**
 * *
 * The P2WSH address of the channel funding multisig address that the below
 * specified amount in satoshis needs to be sent to.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *fundingAddress;

/**
 * *
 * The exact amount in satoshis that needs to be sent to the above address to
 * fund the pending channel.
 **/
@property(nonatomic, readwrite) int64_t fundingAmount;

/**
 * *
 * A raw PSBT that contains the pending channel output. If a base PSBT was
 * provided in the PsbtShim, this is the base PSBT with one additional output.
 * If no base PSBT was specified, this is an otherwise empty PSBT with exactly
 * one output.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *psbt;

@end

#pragma mark - OpenChannelRequest

typedef GPB_ENUM(OpenChannelRequest_FieldNumber) {
  OpenChannelRequest_FieldNumber_NodePubkey = 2,
  OpenChannelRequest_FieldNumber_NodePubkeyString = 3,
  OpenChannelRequest_FieldNumber_LocalFundingAmount = 4,
  OpenChannelRequest_FieldNumber_PushSat = 5,
  OpenChannelRequest_FieldNumber_TargetConf = 6,
  OpenChannelRequest_FieldNumber_SatPerByte = 7,
  OpenChannelRequest_FieldNumber_Private_p = 8,
  OpenChannelRequest_FieldNumber_MinHtlcMsat = 9,
  OpenChannelRequest_FieldNumber_RemoteCsvDelay = 10,
  OpenChannelRequest_FieldNumber_MinConfs = 11,
  OpenChannelRequest_FieldNumber_SpendUnconfirmed = 12,
  OpenChannelRequest_FieldNumber_CloseAddress = 13,
  OpenChannelRequest_FieldNumber_FundingShim = 14,
};

@interface OpenChannelRequest : GPBMessage

/**
 * *
 * The pubkey of the node to open a channel with. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *nodePubkey;

/**
 * *
 * The hex encoded pubkey of the node to open a channel with. Deprecated now
 * that the REST gateway supports base64 encoding of bytes fields.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *nodePubkeyString GPB_DEPRECATED_MSG("lnrpc.OpenChannelRequest.node_pubkey_string is deprecated (see rpc.proto).");

/** / The number of satoshis the wallet should commit to the channel */
@property(nonatomic, readwrite) int64_t localFundingAmount;

/**
 * / The number of satoshis to push to the remote side as part of the initial
 * / commitment state
 **/
@property(nonatomic, readwrite) int64_t pushSat;

/**
 * / The target number of blocks that the funding transaction should be
 * / confirmed by.
 **/
@property(nonatomic, readwrite) int32_t targetConf;

/**
 * / A manual fee rate set in sat/byte that should be used when crafting the
 * / funding transaction.
 **/
@property(nonatomic, readwrite) int64_t satPerByte;

/**
 * / Whether this channel should be private, not announced to the greater
 * / network.
 **/
@property(nonatomic, readwrite) BOOL private_p;

/**
 * / The minimum value in millisatoshi we will require for incoming HTLCs on
 * / the channel.
 **/
@property(nonatomic, readwrite) int64_t minHtlcMsat;

/**
 * / The delay we require on the remote's commitment transaction. If this is
 * / not set, it will be scaled automatically with the channel size.
 **/
@property(nonatomic, readwrite) uint32_t remoteCsvDelay;

/**
 * / The minimum number of confirmations each one of your outputs used for
 * / the funding transaction must satisfy.
 **/
@property(nonatomic, readwrite) int32_t minConfs;

/**
 * / Whether unconfirmed outputs should be used as inputs for the funding
 * / transaction.
 **/
@property(nonatomic, readwrite) BOOL spendUnconfirmed;

/**
 *
 * Close address is an optional address which specifies the address to which
 * funds should be paid out to upon cooperative close. This field may only be
 * set if the peer supports the option upfront feature bit (call listpeers
 * to check). The remote peer will only accept cooperative closes to this
 * address if it is set.
 *
 * Note: If this value is set on channel creation, you will *not* be able to
 * cooperatively close out to a different address.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *closeAddress;

/**
 * *
 * Funding shims are an optional argument that allow the caller to intercept
 * certain funding functionality. For example, a shim can be provided to use a
 * particular key for the commitment key (ideally cold) rather than use one
 * that is generated by the wallet as normal, or signal that signing will be
 * carried out in an interactive manner (PSBT based).
 **/
@property(nonatomic, readwrite, strong, null_resettable) FundingShim *fundingShim;
/** Test to see if @c fundingShim has been set. */
@property(nonatomic, readwrite) BOOL hasFundingShim;

@end

#pragma mark - OpenStatusUpdate

typedef GPB_ENUM(OpenStatusUpdate_FieldNumber) {
  OpenStatusUpdate_FieldNumber_ChanPending = 1,
  OpenStatusUpdate_FieldNumber_ChanOpen = 3,
  OpenStatusUpdate_FieldNumber_PendingChanId = 4,
  OpenStatusUpdate_FieldNumber_PsbtFund = 5,
};

typedef GPB_ENUM(OpenStatusUpdate_Update_OneOfCase) {
  OpenStatusUpdate_Update_OneOfCase_GPBUnsetOneOfCase = 0,
  OpenStatusUpdate_Update_OneOfCase_ChanPending = 1,
  OpenStatusUpdate_Update_OneOfCase_ChanOpen = 3,
  OpenStatusUpdate_Update_OneOfCase_PsbtFund = 5,
};

@interface OpenStatusUpdate : GPBMessage

@property(nonatomic, readonly) OpenStatusUpdate_Update_OneOfCase updateOneOfCase;

/**
 * *
 * Signals that the channel is now fully negotiated and the funding
 * transaction published.
 **/
@property(nonatomic, readwrite, strong, null_resettable) PendingUpdate *chanPending;

/**
 * *
 * Signals that the channel's funding transaction has now reached the
 * required number of confirmations on chain and can be used.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChannelOpenUpdate *chanOpen;

/**
 * *
 * Signals that the funding process has been suspended and the construction
 * of a PSBT that funds the channel PK script is now required.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ReadyForPsbtFunding *psbtFund;

/**
 * *
 * The pending channel ID of the created channel. This value may be used to
 * further the funding flow manually via the FundingStateStep method.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

@end

/**
 * Clears whatever value was set for the oneof 'update'.
 **/
void OpenStatusUpdate_ClearUpdateOneOfCase(OpenStatusUpdate *message);

#pragma mark - KeyLocator

typedef GPB_ENUM(KeyLocator_FieldNumber) {
  KeyLocator_FieldNumber_KeyFamily = 1,
  KeyLocator_FieldNumber_KeyIndex = 2,
};

@interface KeyLocator : GPBMessage

/** / The family of key being identified. */
@property(nonatomic, readwrite) int32_t keyFamily;

/** / The precise index of the key being identified. */
@property(nonatomic, readwrite) int32_t keyIndex;

@end

#pragma mark - KeyDescriptor

typedef GPB_ENUM(KeyDescriptor_FieldNumber) {
  KeyDescriptor_FieldNumber_RawKeyBytes = 1,
  KeyDescriptor_FieldNumber_KeyLoc = 2,
};

@interface KeyDescriptor : GPBMessage

/**
 * *
 * The raw bytes of the key being identified.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *rawKeyBytes;

/**
 * *
 * The key locator that identifies which key to use for signing.
 **/
@property(nonatomic, readwrite, strong, null_resettable) KeyLocator *keyLoc;
/** Test to see if @c keyLoc has been set. */
@property(nonatomic, readwrite) BOOL hasKeyLoc;

@end

#pragma mark - ChanPointShim

typedef GPB_ENUM(ChanPointShim_FieldNumber) {
  ChanPointShim_FieldNumber_Amt = 1,
  ChanPointShim_FieldNumber_ChanPoint = 2,
  ChanPointShim_FieldNumber_LocalKey = 3,
  ChanPointShim_FieldNumber_RemoteKey = 4,
  ChanPointShim_FieldNumber_PendingChanId = 5,
  ChanPointShim_FieldNumber_ThawHeight = 6,
};

@interface ChanPointShim : GPBMessage

/**
 * *
 * The size of the pre-crafted output to be used as the channel point for this
 * channel funding.
 **/
@property(nonatomic, readwrite) int64_t amt;

/** / The target channel point to refrence in created commitment transactions. */
@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;
/** Test to see if @c chanPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChanPoint;

/** / Our local key to use when creating the multi-sig output. */
@property(nonatomic, readwrite, strong, null_resettable) KeyDescriptor *localKey;
/** Test to see if @c localKey has been set. */
@property(nonatomic, readwrite) BOOL hasLocalKey;

/** / The key of the remote party to use when creating the multi-sig output. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *remoteKey;

/**
 * *
 * If non-zero, then this will be used as the pending channel ID on the wire
 * protocol to initate the funding request. This is an optional field, and
 * should only be set if the responder is already expecting a specific pending
 * channel ID.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

/**
 * *
 * This uint32 indicates if this channel is to be considered 'frozen'. A
 * frozen channel does not allow a cooperative channel close by the
 * initiator. The thaw_height is the height that this restriction stops
 * applying to the channel.
 **/
@property(nonatomic, readwrite) uint32_t thawHeight;

@end

#pragma mark - PsbtShim

typedef GPB_ENUM(PsbtShim_FieldNumber) {
  PsbtShim_FieldNumber_PendingChanId = 1,
  PsbtShim_FieldNumber_BasePsbt = 2,
};

@interface PsbtShim : GPBMessage

/**
 * *
 * A unique identifier of 32 random bytes that will be used as the pending
 * channel ID to identify the PSBT state machine when interacting with it and
 * on the wire protocol to initiate the funding request.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

/**
 * *
 * An optional base PSBT the new channel output will be added to. If this is
 * non-empty, it must be a binary serialized PSBT.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *basePsbt;

@end

#pragma mark - FundingShim

typedef GPB_ENUM(FundingShim_FieldNumber) {
  FundingShim_FieldNumber_ChanPointShim = 1,
  FundingShim_FieldNumber_PsbtShim = 2,
};

typedef GPB_ENUM(FundingShim_Shim_OneOfCase) {
  FundingShim_Shim_OneOfCase_GPBUnsetOneOfCase = 0,
  FundingShim_Shim_OneOfCase_ChanPointShim = 1,
  FundingShim_Shim_OneOfCase_PsbtShim = 2,
};

@interface FundingShim : GPBMessage

@property(nonatomic, readonly) FundingShim_Shim_OneOfCase shimOneOfCase;

/**
 * *
 * A channel shim where the channel point was fully constructed outside
 * of lnd's wallet and the transaction might already be published.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChanPointShim *chanPointShim;

/**
 * *
 * A channel shim that uses a PSBT to fund and sign the channel funding
 * transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) PsbtShim *psbtShim;

@end

/**
 * Clears whatever value was set for the oneof 'shim'.
 **/
void FundingShim_ClearShimOneOfCase(FundingShim *message);

#pragma mark - FundingShimCancel

typedef GPB_ENUM(FundingShimCancel_FieldNumber) {
  FundingShimCancel_FieldNumber_PendingChanId = 1,
};

@interface FundingShimCancel : GPBMessage

/** / The pending channel ID of the channel to cancel the funding shim for. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

@end

#pragma mark - FundingPsbtVerify

typedef GPB_ENUM(FundingPsbtVerify_FieldNumber) {
  FundingPsbtVerify_FieldNumber_FundedPsbt = 1,
  FundingPsbtVerify_FieldNumber_PendingChanId = 2,
};

@interface FundingPsbtVerify : GPBMessage

/**
 * *
 * The funded but not yet signed PSBT that sends the exact channel capacity
 * amount to the PK script returned in the open channel message in a previous
 * step.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *fundedPsbt;

/** / The pending channel ID of the channel to get the PSBT for. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

@end

#pragma mark - FundingPsbtFinalize

typedef GPB_ENUM(FundingPsbtFinalize_FieldNumber) {
  FundingPsbtFinalize_FieldNumber_SignedPsbt = 1,
  FundingPsbtFinalize_FieldNumber_PendingChanId = 2,
};

@interface FundingPsbtFinalize : GPBMessage

/**
 * *
 * The funded PSBT that contains all witness data to send the exact channel
 * capacity amount to the PK script returned in the open channel message in a
 * previous step.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *signedPsbt;

/** / The pending channel ID of the channel to get the PSBT for. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *pendingChanId;

@end

#pragma mark - FundingTransitionMsg

typedef GPB_ENUM(FundingTransitionMsg_FieldNumber) {
  FundingTransitionMsg_FieldNumber_ShimRegister = 1,
  FundingTransitionMsg_FieldNumber_ShimCancel = 2,
  FundingTransitionMsg_FieldNumber_PsbtVerify = 3,
  FundingTransitionMsg_FieldNumber_PsbtFinalize = 4,
};

typedef GPB_ENUM(FundingTransitionMsg_Trigger_OneOfCase) {
  FundingTransitionMsg_Trigger_OneOfCase_GPBUnsetOneOfCase = 0,
  FundingTransitionMsg_Trigger_OneOfCase_ShimRegister = 1,
  FundingTransitionMsg_Trigger_OneOfCase_ShimCancel = 2,
  FundingTransitionMsg_Trigger_OneOfCase_PsbtVerify = 3,
  FundingTransitionMsg_Trigger_OneOfCase_PsbtFinalize = 4,
};

@interface FundingTransitionMsg : GPBMessage

@property(nonatomic, readonly) FundingTransitionMsg_Trigger_OneOfCase triggerOneOfCase;

/**
 * *
 * The funding shim to register. This should be used before any
 * channel funding has began by the remote party, as it is intended as a
 * preparatory step for the full channel funding.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FundingShim *shimRegister;

/** / Used to cancel an existing registered funding shim. */
@property(nonatomic, readwrite, strong, null_resettable) FundingShimCancel *shimCancel;

/**
 * *
 * Used to continue a funding flow that was initiated to be executed
 * through a PSBT. This step verifies that the PSBT contains the correct
 * outputs to fund the channel.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FundingPsbtVerify *psbtVerify;

/**
 * *
 * Used to continue a funding flow that was initiated to be executed
 * through a PSBT. This step finalizes the funded and signed PSBT, finishes
 * negotiation with the peer and finally publishes the resulting funding
 * transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FundingPsbtFinalize *psbtFinalize;

@end

/**
 * Clears whatever value was set for the oneof 'trigger'.
 **/
void FundingTransitionMsg_ClearTriggerOneOfCase(FundingTransitionMsg *message);

#pragma mark - FundingStateStepResp

@interface FundingStateStepResp : GPBMessage

@end

#pragma mark - PendingHTLC

typedef GPB_ENUM(PendingHTLC_FieldNumber) {
  PendingHTLC_FieldNumber_Incoming = 1,
  PendingHTLC_FieldNumber_Amount = 2,
  PendingHTLC_FieldNumber_Outpoint = 3,
  PendingHTLC_FieldNumber_MaturityHeight = 4,
  PendingHTLC_FieldNumber_BlocksTilMaturity = 5,
  PendingHTLC_FieldNumber_Stage = 6,
};

@interface PendingHTLC : GPBMessage

/** / The direction within the channel that the htlc was sent */
@property(nonatomic, readwrite) BOOL incoming;

/** / The total value of the htlc */
@property(nonatomic, readwrite) int64_t amount;

/** / The final output to be swept back to the user's wallet */
@property(nonatomic, readwrite, copy, null_resettable) NSString *outpoint;

/** / The next block height at which we can spend the current stage */
@property(nonatomic, readwrite) uint32_t maturityHeight;

/**
 * *
 * The number of blocks remaining until the current stage can be swept.
 * Negative values indicate how many blocks have passed since becoming
 * mature.
 **/
@property(nonatomic, readwrite) int32_t blocksTilMaturity;

/** / Indicates whether the htlc is in its first or second stage of recovery */
@property(nonatomic, readwrite) uint32_t stage;

@end

#pragma mark - PendingChannelsRequest

@interface PendingChannelsRequest : GPBMessage

@end

#pragma mark - PendingChannelsResponse

typedef GPB_ENUM(PendingChannelsResponse_FieldNumber) {
  PendingChannelsResponse_FieldNumber_TotalLimboBalance = 1,
  PendingChannelsResponse_FieldNumber_PendingOpenChannelsArray = 2,
  PendingChannelsResponse_FieldNumber_PendingClosingChannelsArray = 3,
  PendingChannelsResponse_FieldNumber_PendingForceClosingChannelsArray = 4,
  PendingChannelsResponse_FieldNumber_WaitingCloseChannelsArray = 5,
};

@interface PendingChannelsResponse : GPBMessage

/** / The balance in satoshis encumbered in pending channels */
@property(nonatomic, readwrite) int64_t totalLimboBalance;

/** / Channels pending opening */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PendingChannelsResponse_PendingOpenChannel*> *pendingOpenChannelsArray;
/** The number of items in @c pendingOpenChannelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger pendingOpenChannelsArray_Count;

/**
 *
 * Deprecated: Channels pending closing previously contained cooperatively
 * closed channels with a single confirmation. These channels are now
 * considered closed from the time we see them on chain.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PendingChannelsResponse_ClosedChannel*> *pendingClosingChannelsArray GPB_DEPRECATED_MSG("lnrpc.PendingChannelsResponse.pending_closing_channels is deprecated (see rpc.proto).");
/** The number of items in @c pendingClosingChannelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger pendingClosingChannelsArray_Count GPB_DEPRECATED_MSG("lnrpc.PendingChannelsResponse.pending_closing_channels is deprecated (see rpc.proto).");

/** / Channels pending force closing */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PendingChannelsResponse_ForceClosedChannel*> *pendingForceClosingChannelsArray;
/** The number of items in @c pendingForceClosingChannelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger pendingForceClosingChannelsArray_Count;

/** / Channels waiting for closing tx to confirm */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PendingChannelsResponse_WaitingCloseChannel*> *waitingCloseChannelsArray;
/** The number of items in @c waitingCloseChannelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger waitingCloseChannelsArray_Count;

@end

#pragma mark - PendingChannelsResponse_PendingChannel

typedef GPB_ENUM(PendingChannelsResponse_PendingChannel_FieldNumber) {
  PendingChannelsResponse_PendingChannel_FieldNumber_RemoteNodePub = 1,
  PendingChannelsResponse_PendingChannel_FieldNumber_ChannelPoint = 2,
  PendingChannelsResponse_PendingChannel_FieldNumber_Capacity = 3,
  PendingChannelsResponse_PendingChannel_FieldNumber_LocalBalance = 4,
  PendingChannelsResponse_PendingChannel_FieldNumber_RemoteBalance = 5,
  PendingChannelsResponse_PendingChannel_FieldNumber_LocalChanReserveSat = 6,
  PendingChannelsResponse_PendingChannel_FieldNumber_RemoteChanReserveSat = 7,
  PendingChannelsResponse_PendingChannel_FieldNumber_Initiator = 8,
  PendingChannelsResponse_PendingChannel_FieldNumber_CommitmentType = 9,
};

@interface PendingChannelsResponse_PendingChannel : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *remoteNodePub;

@property(nonatomic, readwrite, copy, null_resettable) NSString *channelPoint;

@property(nonatomic, readwrite) int64_t capacity;

@property(nonatomic, readwrite) int64_t localBalance;

@property(nonatomic, readwrite) int64_t remoteBalance;

/**
 * / The minimum satoshis this node is required to reserve in its
 * / balance.
 **/
@property(nonatomic, readwrite) int64_t localChanReserveSat;

/**
 * *
 * The minimum satoshis the other node is required to reserve in its
 * balance.
 **/
@property(nonatomic, readwrite) int64_t remoteChanReserveSat;

/** The party that initiated opening the channel. */
@property(nonatomic, readwrite) Initiator initiator;

/** / The commitment type used by this channel. */
@property(nonatomic, readwrite) CommitmentType commitmentType;

@end

/**
 * Fetches the raw value of a @c PendingChannelsResponse_PendingChannel's @c initiator property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PendingChannelsResponse_PendingChannel_Initiator_RawValue(PendingChannelsResponse_PendingChannel *message);
/**
 * Sets the raw value of an @c PendingChannelsResponse_PendingChannel's @c initiator property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPendingChannelsResponse_PendingChannel_Initiator_RawValue(PendingChannelsResponse_PendingChannel *message, int32_t value);

/**
 * Fetches the raw value of a @c PendingChannelsResponse_PendingChannel's @c commitmentType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PendingChannelsResponse_PendingChannel_CommitmentType_RawValue(PendingChannelsResponse_PendingChannel *message);
/**
 * Sets the raw value of an @c PendingChannelsResponse_PendingChannel's @c commitmentType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPendingChannelsResponse_PendingChannel_CommitmentType_RawValue(PendingChannelsResponse_PendingChannel *message, int32_t value);

#pragma mark - PendingChannelsResponse_PendingOpenChannel

typedef GPB_ENUM(PendingChannelsResponse_PendingOpenChannel_FieldNumber) {
  PendingChannelsResponse_PendingOpenChannel_FieldNumber_Channel = 1,
  PendingChannelsResponse_PendingOpenChannel_FieldNumber_ConfirmationHeight = 2,
  PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitFee = 4,
  PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitWeight = 5,
  PendingChannelsResponse_PendingOpenChannel_FieldNumber_FeePerKw = 6,
};

@interface PendingChannelsResponse_PendingOpenChannel : GPBMessage

/** / The pending channel */
@property(nonatomic, readwrite, strong, null_resettable) PendingChannelsResponse_PendingChannel *channel;
/** Test to see if @c channel has been set. */
@property(nonatomic, readwrite) BOOL hasChannel;

/** / The height at which this channel will be confirmed */
@property(nonatomic, readwrite) uint32_t confirmationHeight;

/**
 * *
 * The amount calculated to be paid in fees for the current set of
 * commitment transactions. The fee amount is persisted with the channel
 * in order to allow the fee amount to be removed and recalculated with
 * each channel state update, including updates that happen after a system
 * restart.
 **/
@property(nonatomic, readwrite) int64_t commitFee;

/** / The weight of the commitment transaction */
@property(nonatomic, readwrite) int64_t commitWeight;

/**
 * *
 * The required number of satoshis per kilo-weight that the requester will
 * pay at all times, for both the funding transaction and commitment
 * transaction. This value can later be updated once the channel is open.
 **/
@property(nonatomic, readwrite) int64_t feePerKw;

@end

#pragma mark - PendingChannelsResponse_WaitingCloseChannel

typedef GPB_ENUM(PendingChannelsResponse_WaitingCloseChannel_FieldNumber) {
  PendingChannelsResponse_WaitingCloseChannel_FieldNumber_Channel = 1,
  PendingChannelsResponse_WaitingCloseChannel_FieldNumber_LimboBalance = 2,
  PendingChannelsResponse_WaitingCloseChannel_FieldNumber_Commitments = 3,
};

@interface PendingChannelsResponse_WaitingCloseChannel : GPBMessage

/** / The pending channel waiting for closing tx to confirm */
@property(nonatomic, readwrite, strong, null_resettable) PendingChannelsResponse_PendingChannel *channel;
/** Test to see if @c channel has been set. */
@property(nonatomic, readwrite) BOOL hasChannel;

/** / The balance in satoshis encumbered in this channel */
@property(nonatomic, readwrite) int64_t limboBalance;

/**
 * *
 * A list of valid commitment transactions. Any of these can confirm at
 * this point.
 **/
@property(nonatomic, readwrite, strong, null_resettable) PendingChannelsResponse_Commitments *commitments;
/** Test to see if @c commitments has been set. */
@property(nonatomic, readwrite) BOOL hasCommitments;

@end

#pragma mark - PendingChannelsResponse_Commitments

typedef GPB_ENUM(PendingChannelsResponse_Commitments_FieldNumber) {
  PendingChannelsResponse_Commitments_FieldNumber_LocalTxid = 1,
  PendingChannelsResponse_Commitments_FieldNumber_RemoteTxid = 2,
  PendingChannelsResponse_Commitments_FieldNumber_RemotePendingTxid = 3,
  PendingChannelsResponse_Commitments_FieldNumber_LocalCommitFeeSat = 4,
  PendingChannelsResponse_Commitments_FieldNumber_RemoteCommitFeeSat = 5,
  PendingChannelsResponse_Commitments_FieldNumber_RemotePendingCommitFeeSat = 6,
};

@interface PendingChannelsResponse_Commitments : GPBMessage

/** / Hash of the local version of the commitment tx. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *localTxid;

/** / Hash of the remote version of the commitment tx. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *remoteTxid;

/** / Hash of the remote pending version of the commitment tx. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *remotePendingTxid;

/**
 *
 * The amount in satoshis calculated to be paid in fees for the local
 * commitment.
 **/
@property(nonatomic, readwrite) uint64_t localCommitFeeSat;

/**
 *
 * The amount in satoshis calculated to be paid in fees for the remote
 * commitment.
 **/
@property(nonatomic, readwrite) uint64_t remoteCommitFeeSat;

/**
 *
 * The amount in satoshis calculated to be paid in fees for the remote
 * pending commitment.
 **/
@property(nonatomic, readwrite) uint64_t remotePendingCommitFeeSat;

@end

#pragma mark - PendingChannelsResponse_ClosedChannel

typedef GPB_ENUM(PendingChannelsResponse_ClosedChannel_FieldNumber) {
  PendingChannelsResponse_ClosedChannel_FieldNumber_Channel = 1,
  PendingChannelsResponse_ClosedChannel_FieldNumber_ClosingTxid = 2,
};

@interface PendingChannelsResponse_ClosedChannel : GPBMessage

/** / The pending channel to be closed */
@property(nonatomic, readwrite, strong, null_resettable) PendingChannelsResponse_PendingChannel *channel;
/** Test to see if @c channel has been set. */
@property(nonatomic, readwrite) BOOL hasChannel;

/** / The transaction id of the closing transaction */
@property(nonatomic, readwrite, copy, null_resettable) NSString *closingTxid;

@end

#pragma mark - PendingChannelsResponse_ForceClosedChannel

typedef GPB_ENUM(PendingChannelsResponse_ForceClosedChannel_FieldNumber) {
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_Channel = 1,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_ClosingTxid = 2,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_LimboBalance = 3,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_MaturityHeight = 4,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_BlocksTilMaturity = 5,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_RecoveredBalance = 6,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_PendingHtlcsArray = 8,
  PendingChannelsResponse_ForceClosedChannel_FieldNumber_Anchor = 9,
};

@interface PendingChannelsResponse_ForceClosedChannel : GPBMessage

/** / The pending channel to be force closed */
@property(nonatomic, readwrite, strong, null_resettable) PendingChannelsResponse_PendingChannel *channel;
/** Test to see if @c channel has been set. */
@property(nonatomic, readwrite) BOOL hasChannel;

/** / The transaction id of the closing transaction */
@property(nonatomic, readwrite, copy, null_resettable) NSString *closingTxid;

/** / The balance in satoshis encumbered in this pending channel */
@property(nonatomic, readwrite) int64_t limboBalance;

/** / The height at which funds can be swept into the wallet */
@property(nonatomic, readwrite) uint32_t maturityHeight;

/**
 *
 * Remaining # of blocks until the commitment output can be swept.
 * Negative values indicate how many blocks have passed since becoming
 * mature.
 **/
@property(nonatomic, readwrite) int32_t blocksTilMaturity;

/** / The total value of funds successfully recovered from this channel */
@property(nonatomic, readwrite) int64_t recoveredBalance;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PendingHTLC*> *pendingHtlcsArray;
/** The number of items in @c pendingHtlcsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger pendingHtlcsArray_Count;

@property(nonatomic, readwrite) PendingChannelsResponse_ForceClosedChannel_AnchorState anchor;

@end

/**
 * Fetches the raw value of a @c PendingChannelsResponse_ForceClosedChannel's @c anchor property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PendingChannelsResponse_ForceClosedChannel_Anchor_RawValue(PendingChannelsResponse_ForceClosedChannel *message);
/**
 * Sets the raw value of an @c PendingChannelsResponse_ForceClosedChannel's @c anchor property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPendingChannelsResponse_ForceClosedChannel_Anchor_RawValue(PendingChannelsResponse_ForceClosedChannel *message, int32_t value);

#pragma mark - ChannelEventSubscription

@interface ChannelEventSubscription : GPBMessage

@end

#pragma mark - ChannelEventUpdate

typedef GPB_ENUM(ChannelEventUpdate_FieldNumber) {
  ChannelEventUpdate_FieldNumber_OpenChannel = 1,
  ChannelEventUpdate_FieldNumber_ClosedChannel = 2,
  ChannelEventUpdate_FieldNumber_ActiveChannel = 3,
  ChannelEventUpdate_FieldNumber_InactiveChannel = 4,
  ChannelEventUpdate_FieldNumber_Type = 5,
  ChannelEventUpdate_FieldNumber_PendingOpenChannel = 6,
};

typedef GPB_ENUM(ChannelEventUpdate_Channel_OneOfCase) {
  ChannelEventUpdate_Channel_OneOfCase_GPBUnsetOneOfCase = 0,
  ChannelEventUpdate_Channel_OneOfCase_OpenChannel = 1,
  ChannelEventUpdate_Channel_OneOfCase_ClosedChannel = 2,
  ChannelEventUpdate_Channel_OneOfCase_ActiveChannel = 3,
  ChannelEventUpdate_Channel_OneOfCase_InactiveChannel = 4,
  ChannelEventUpdate_Channel_OneOfCase_PendingOpenChannel = 6,
};

@interface ChannelEventUpdate : GPBMessage

@property(nonatomic, readonly) ChannelEventUpdate_Channel_OneOfCase channelOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) Channel *openChannel;

@property(nonatomic, readwrite, strong, null_resettable) ChannelCloseSummary *closedChannel;

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *activeChannel;

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *inactiveChannel;

@property(nonatomic, readwrite, strong, null_resettable) PendingUpdate *pendingOpenChannel;

@property(nonatomic, readwrite) ChannelEventUpdate_UpdateType type;

@end

/**
 * Fetches the raw value of a @c ChannelEventUpdate's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t ChannelEventUpdate_Type_RawValue(ChannelEventUpdate *message);
/**
 * Sets the raw value of an @c ChannelEventUpdate's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannelEventUpdate_Type_RawValue(ChannelEventUpdate *message, int32_t value);

/**
 * Clears whatever value was set for the oneof 'channel'.
 **/
void ChannelEventUpdate_ClearChannelOneOfCase(ChannelEventUpdate *message);

#pragma mark - WalletBalanceRequest

@interface WalletBalanceRequest : GPBMessage

@end

#pragma mark - WalletBalanceResponse

typedef GPB_ENUM(WalletBalanceResponse_FieldNumber) {
  WalletBalanceResponse_FieldNumber_TotalBalance = 1,
  WalletBalanceResponse_FieldNumber_ConfirmedBalance = 2,
  WalletBalanceResponse_FieldNumber_UnconfirmedBalance = 3,
};

@interface WalletBalanceResponse : GPBMessage

/** / The balance of the wallet */
@property(nonatomic, readwrite) int64_t totalBalance;

/** / The confirmed balance of a wallet(with >= 1 confirmations) */
@property(nonatomic, readwrite) int64_t confirmedBalance;

/** / The unconfirmed balance of a wallet(with 0 confirmations) */
@property(nonatomic, readwrite) int64_t unconfirmedBalance;

@end

#pragma mark - ChannelBalanceRequest

@interface ChannelBalanceRequest : GPBMessage

@end

#pragma mark - ChannelBalanceResponse

typedef GPB_ENUM(ChannelBalanceResponse_FieldNumber) {
  ChannelBalanceResponse_FieldNumber_Balance = 1,
  ChannelBalanceResponse_FieldNumber_PendingOpenBalance = 2,
};

@interface ChannelBalanceResponse : GPBMessage

/** / Sum of channels balances denominated in satoshis */
@property(nonatomic, readwrite) int64_t balance;

/** / Sum of channels pending balances denominated in satoshis */
@property(nonatomic, readwrite) int64_t pendingOpenBalance;

@end

#pragma mark - QueryRoutesRequest

typedef GPB_ENUM(QueryRoutesRequest_FieldNumber) {
  QueryRoutesRequest_FieldNumber_PubKey = 1,
  QueryRoutesRequest_FieldNumber_Amt = 2,
  QueryRoutesRequest_FieldNumber_FinalCltvDelta = 4,
  QueryRoutesRequest_FieldNumber_FeeLimit = 5,
  QueryRoutesRequest_FieldNumber_IgnoredNodesArray = 6,
  QueryRoutesRequest_FieldNumber_IgnoredEdgesArray = 7,
  QueryRoutesRequest_FieldNumber_SourcePubKey = 8,
  QueryRoutesRequest_FieldNumber_UseMissionControl = 9,
  QueryRoutesRequest_FieldNumber_IgnoredPairsArray = 10,
  QueryRoutesRequest_FieldNumber_CltvLimit = 11,
  QueryRoutesRequest_FieldNumber_AmtMsat = 12,
  QueryRoutesRequest_FieldNumber_DestCustomRecords = 13,
  QueryRoutesRequest_FieldNumber_OutgoingChanId = 14,
  QueryRoutesRequest_FieldNumber_LastHopPubkey = 15,
  QueryRoutesRequest_FieldNumber_RouteHintsArray = 16,
  QueryRoutesRequest_FieldNumber_DestFeaturesArray = 17,
};

@interface QueryRoutesRequest : GPBMessage

/** / The 33-byte hex-encoded public key for the payment destination */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

/**
 * *
 * The amount to send expressed in satoshis.
 *
 * The fields amt and amt_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t amt;

/**
 * *
 * The amount to send expressed in millisatoshis.
 *
 * The fields amt and amt_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t amtMsat;

/**
 * *
 * An optional CLTV delta from the current height that should be used for the
 * timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
 * not add any additional block padding on top of final_ctlv_delta. This
 * padding of a few blocks needs to be added manually or otherwise failures may
 * happen when a block comes in while the payment is in flight.
 **/
@property(nonatomic, readwrite) int32_t finalCltvDelta;

/**
 * *
 * The maximum number of satoshis that will be paid as a fee of the payment.
 * This value can be represented either as a percentage of the amount being
 * sent, or as a fixed amount of the maximum fee the user is willing the pay to
 * send the payment.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FeeLimit *feeLimit;
/** Test to see if @c feeLimit has been set. */
@property(nonatomic, readwrite) BOOL hasFeeLimit;

/**
 * *
 * A list of nodes to ignore during path finding. When using REST, these fields
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *ignoredNodesArray;
/** The number of items in @c ignoredNodesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger ignoredNodesArray_Count;

/**
 * *
 * Deprecated. A list of edges to ignore during path finding.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<EdgeLocator*> *ignoredEdgesArray GPB_DEPRECATED_MSG("lnrpc.QueryRoutesRequest.ignored_edges is deprecated (see rpc.proto).");
/** The number of items in @c ignoredEdgesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger ignoredEdgesArray_Count GPB_DEPRECATED_MSG("lnrpc.QueryRoutesRequest.ignored_edges is deprecated (see rpc.proto).");

/**
 * *
 * The source node where the request route should originated from. If empty,
 * self is assumed.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *sourcePubKey;

/**
 * *
 * If set to true, edge probabilities from mission control will be used to get
 * the optimal route.
 **/
@property(nonatomic, readwrite) BOOL useMissionControl;

/**
 * *
 * A list of directed node pairs that will be ignored during path finding.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NodePair*> *ignoredPairsArray;
/** The number of items in @c ignoredPairsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger ignoredPairsArray_Count;

/**
 * *
 * An optional maximum total time lock for the route. If the source is empty or
 * ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
 * zero, then the value of `--max-cltv-expiry` is used as the limit.
 **/
@property(nonatomic, readwrite) uint32_t cltvLimit;

/**
 * *
 * An optional field that can be used to pass an arbitrary set of TLV records
 * to a peer which understands the new records. This can be used to pass
 * application specific data during the payment attempt. If the destination
 * does not support the specified recrods, and error will be returned.
 * Record types are required to be in the custom range >= 65536. When using
 * REST, the values must be encoded as base64.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt64ObjectDictionary<NSData*> *destCustomRecords;
/** The number of items in @c destCustomRecords without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger destCustomRecords_Count;

/**
 * *
 * The channel id of the channel that must be taken to the first hop. If zero,
 * any channel may be used.
 **/
@property(nonatomic, readwrite) uint64_t outgoingChanId;

/**
 * *
 * The pubkey of the last hop of the route. If empty, any hop may be used.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *lastHopPubkey;

/**
 * *
 * Optional route hints to reach the destination through private channels.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<RouteHint*> *routeHintsArray;
/** The number of items in @c routeHintsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger routeHintsArray_Count;

/**
 * *
 * Features assumed to be supported by the final node. All transitive feature
 * dependencies must also be set properly. For a given feature bit pair, either
 * optional or remote may be set, but not both. If this field is nil or empty,
 * the router will try to load destination features from the graph as a
 * fallback.
 **/
// |destFeaturesArray| contains |FeatureBit|
@property(nonatomic, readwrite, strong, null_resettable) GPBEnumArray *destFeaturesArray;
/** The number of items in @c destFeaturesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger destFeaturesArray_Count;

@end

#pragma mark - NodePair

typedef GPB_ENUM(NodePair_FieldNumber) {
  NodePair_FieldNumber_From = 1,
  NodePair_FieldNumber_To = 2,
};

@interface NodePair : GPBMessage

/**
 * *
 * The sending node of the pair. When using REST, this field must be encoded as
 * base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *from;

/**
 * *
 * The receiving node of the pair. When using REST, this field must be encoded
 * as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *to;

@end

#pragma mark - EdgeLocator

typedef GPB_ENUM(EdgeLocator_FieldNumber) {
  EdgeLocator_FieldNumber_ChannelId = 1,
  EdgeLocator_FieldNumber_DirectionReverse = 2,
};

@interface EdgeLocator : GPBMessage

/** / The short channel id of this edge. */
@property(nonatomic, readwrite) uint64_t channelId;

/**
 * *
 * The direction of this edge. If direction_reverse is false, the direction
 * of this edge is from the channel endpoint with the lexicographically smaller
 * pub key to the endpoint with the larger pub key. If direction_reverse is
 * is true, the edge goes the other way.
 **/
@property(nonatomic, readwrite) BOOL directionReverse;

@end

#pragma mark - QueryRoutesResponse

typedef GPB_ENUM(QueryRoutesResponse_FieldNumber) {
  QueryRoutesResponse_FieldNumber_RoutesArray = 1,
  QueryRoutesResponse_FieldNumber_SuccessProb = 2,
};

@interface QueryRoutesResponse : GPBMessage

/**
 * *
 * The route that results from the path finding operation. This is still a
 * repeated field to retain backwards compatibility.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Route*> *routesArray;
/** The number of items in @c routesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger routesArray_Count;

/**
 * *
 * The success probability of the returned route based on the current mission
 * control state. [EXPERIMENTAL]
 **/
@property(nonatomic, readwrite) double successProb;

@end

#pragma mark - Hop

typedef GPB_ENUM(Hop_FieldNumber) {
  Hop_FieldNumber_ChanId = 1,
  Hop_FieldNumber_ChanCapacity = 2,
  Hop_FieldNumber_AmtToForward = 3,
  Hop_FieldNumber_Fee = 4,
  Hop_FieldNumber_Expiry = 5,
  Hop_FieldNumber_AmtToForwardMsat = 6,
  Hop_FieldNumber_FeeMsat = 7,
  Hop_FieldNumber_PubKey = 8,
  Hop_FieldNumber_TlvPayload = 9,
  Hop_FieldNumber_MppRecord = 10,
  Hop_FieldNumber_CustomRecords = 11,
};

@interface Hop : GPBMessage

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

@property(nonatomic, readwrite) int64_t chanCapacity;

@property(nonatomic, readwrite) int64_t amtToForward GPB_DEPRECATED_MSG("lnrpc.Hop.amt_to_forward is deprecated (see rpc.proto).");

@property(nonatomic, readwrite) int64_t fee GPB_DEPRECATED_MSG("lnrpc.Hop.fee is deprecated (see rpc.proto).");

@property(nonatomic, readwrite) uint32_t expiry;

@property(nonatomic, readwrite) int64_t amtToForwardMsat;

@property(nonatomic, readwrite) int64_t feeMsat;

/**
 * *
 * An optional public key of the hop. If the public key is given, the payment
 * can be executed without relying on a copy of the channel graph.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

/**
 * *
 * If set to true, then this hop will be encoded using the new variable length
 * TLV format. Note that if any custom tlv_records below are specified, then
 * this field MUST be set to true for them to be encoded properly.
 **/
@property(nonatomic, readwrite) BOOL tlvPayload;

/**
 * *
 * An optional TLV record that signals the use of an MPP payment. If present,
 * the receiver will enforce that that the same mpp_record is included in the
 * final hop payload of all non-zero payments in the HTLC set. If empty, a
 * regular single-shot payment is or was attempted.
 **/
@property(nonatomic, readwrite, strong, null_resettable) MPPRecord *mppRecord;
/** Test to see if @c mppRecord has been set. */
@property(nonatomic, readwrite) BOOL hasMppRecord;

/**
 * *
 * An optional set of key-value TLV records. This is useful within the context
 * of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
 * to drop off at each hop within the onion.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt64ObjectDictionary<NSData*> *customRecords;
/** The number of items in @c customRecords without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger customRecords_Count;

@end

#pragma mark - MPPRecord

typedef GPB_ENUM(MPPRecord_FieldNumber) {
  MPPRecord_FieldNumber_TotalAmtMsat = 10,
  MPPRecord_FieldNumber_PaymentAddr = 11,
};

@interface MPPRecord : GPBMessage

/**
 * *
 * A unique, random identifier used to authenticate the sender as the intended
 * payer of a multi-path payment. The payment_addr must be the same for all
 * subpayments, and match the payment_addr provided in the receiver's invoice.
 * The same payment_addr must be used on all subpayments.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentAddr;

/**
 * *
 * The total amount in milli-satoshis being sent as part of a larger multi-path
 * payment. The caller is responsible for ensuring subpayments to the same node
 * and payment_hash sum exactly to total_amt_msat. The same
 * total_amt_msat must be used on all subpayments.
 **/
@property(nonatomic, readwrite) int64_t totalAmtMsat;

@end

#pragma mark - Route

typedef GPB_ENUM(Route_FieldNumber) {
  Route_FieldNumber_TotalTimeLock = 1,
  Route_FieldNumber_TotalFees = 2,
  Route_FieldNumber_TotalAmt = 3,
  Route_FieldNumber_HopsArray = 4,
  Route_FieldNumber_TotalFeesMsat = 5,
  Route_FieldNumber_TotalAmtMsat = 6,
};

/**
 * *
 * A path through the channel graph which runs over one or more channels in
 * succession. This struct carries all the information required to craft the
 * Sphinx onion packet, and send the payment along the first hop in the path. A
 * route is only selected as valid if all the channels have sufficient capacity to
 * carry the initial payment amount after fees are accounted for.
 **/
@interface Route : GPBMessage

/**
 * *
 * The cumulative (final) time lock across the entire route. This is the CLTV
 * value that should be extended to the first hop in the route. All other hops
 * will decrement the time-lock as advertised, leaving enough time for all
 * hops to wait for or present the payment preimage to complete the payment.
 **/
@property(nonatomic, readwrite) uint32_t totalTimeLock;

/**
 * *
 * The sum of the fees paid at each hop within the final route. In the case
 * of a one-hop payment, this value will be zero as we don't need to pay a fee
 * to ourselves.
 **/
@property(nonatomic, readwrite) int64_t totalFees GPB_DEPRECATED_MSG("lnrpc.Route.total_fees is deprecated (see rpc.proto).");

/**
 * *
 * The total amount of funds required to complete a payment over this route.
 * This value includes the cumulative fees at each hop. As a result, the HTLC
 * extended to the first-hop in the route will need to have at least this many
 * satoshis, otherwise the route will fail at an intermediate node due to an
 * insufficient amount of fees.
 **/
@property(nonatomic, readwrite) int64_t totalAmt GPB_DEPRECATED_MSG("lnrpc.Route.total_amt is deprecated (see rpc.proto).");

/**
 * *
 * Contains details concerning the specific forwarding details at each hop.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Hop*> *hopsArray;
/** The number of items in @c hopsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger hopsArray_Count;

/**
 * *
 * The total fees in millisatoshis.
 **/
@property(nonatomic, readwrite) int64_t totalFeesMsat;

/**
 * *
 * The total amount in millisatoshis.
 **/
@property(nonatomic, readwrite) int64_t totalAmtMsat;

@end

#pragma mark - NodeInfoRequest

typedef GPB_ENUM(NodeInfoRequest_FieldNumber) {
  NodeInfoRequest_FieldNumber_PubKey = 1,
  NodeInfoRequest_FieldNumber_IncludeChannels = 2,
};

@interface NodeInfoRequest : GPBMessage

/** / The 33-byte hex-encoded compressed public of the target node */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

/** / If true, will include all known channels associated with the node. */
@property(nonatomic, readwrite) BOOL includeChannels;

@end

#pragma mark - NodeInfo

typedef GPB_ENUM(NodeInfo_FieldNumber) {
  NodeInfo_FieldNumber_Node = 1,
  NodeInfo_FieldNumber_NumChannels = 2,
  NodeInfo_FieldNumber_TotalCapacity = 3,
  NodeInfo_FieldNumber_ChannelsArray = 4,
};

@interface NodeInfo : GPBMessage

/**
 * *
 * An individual vertex/node within the channel graph. A node is
 * connected to other nodes by one or more channel edges emanating from it. As
 * the graph is directed, a node will also have an incoming edge attached to
 * it for each outgoing edge.
 **/
@property(nonatomic, readwrite, strong, null_resettable) LightningNode *node;
/** Test to see if @c node has been set. */
@property(nonatomic, readwrite) BOOL hasNode;

/** / The total number of channels for the node. */
@property(nonatomic, readwrite) uint32_t numChannels;

/** / The sum of all channels capacity for the node, denominated in satoshis. */
@property(nonatomic, readwrite) int64_t totalCapacity;

/** / A list of all public channels for the node. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelEdge*> *channelsArray;
/** The number of items in @c channelsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger channelsArray_Count;

@end

#pragma mark - LightningNode

typedef GPB_ENUM(LightningNode_FieldNumber) {
  LightningNode_FieldNumber_LastUpdate = 1,
  LightningNode_FieldNumber_PubKey = 2,
  LightningNode_FieldNumber_Alias = 3,
  LightningNode_FieldNumber_AddressesArray = 4,
  LightningNode_FieldNumber_Color = 5,
  LightningNode_FieldNumber_Features = 6,
};

/**
 * *
 * An individual vertex/node within the channel graph. A node is
 * connected to other nodes by one or more channel edges emanating from it. As the
 * graph is directed, a node will also have an incoming edge attached to it for
 * each outgoing edge.
 **/
@interface LightningNode : GPBMessage

@property(nonatomic, readwrite) uint32_t lastUpdate;

@property(nonatomic, readwrite, copy, null_resettable) NSString *pubKey;

@property(nonatomic, readwrite, copy, null_resettable) NSString *alias;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NodeAddress*> *addressesArray;
/** The number of items in @c addressesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger addressesArray_Count;

@property(nonatomic, readwrite, copy, null_resettable) NSString *color;

@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32ObjectDictionary<Feature*> *features;
/** The number of items in @c features without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger features_Count;

@end

#pragma mark - NodeAddress

typedef GPB_ENUM(NodeAddress_FieldNumber) {
  NodeAddress_FieldNumber_Network = 1,
  NodeAddress_FieldNumber_Addr = 2,
};

@interface NodeAddress : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *network;

@property(nonatomic, readwrite, copy, null_resettable) NSString *addr;

@end

#pragma mark - RoutingPolicy

typedef GPB_ENUM(RoutingPolicy_FieldNumber) {
  RoutingPolicy_FieldNumber_TimeLockDelta = 1,
  RoutingPolicy_FieldNumber_MinHtlc = 2,
  RoutingPolicy_FieldNumber_FeeBaseMsat = 3,
  RoutingPolicy_FieldNumber_FeeRateMilliMsat = 4,
  RoutingPolicy_FieldNumber_Disabled = 5,
  RoutingPolicy_FieldNumber_MaxHtlcMsat = 6,
  RoutingPolicy_FieldNumber_LastUpdate = 7,
};

@interface RoutingPolicy : GPBMessage

@property(nonatomic, readwrite) uint32_t timeLockDelta;

@property(nonatomic, readwrite) int64_t minHtlc;

@property(nonatomic, readwrite) int64_t feeBaseMsat;

@property(nonatomic, readwrite) int64_t feeRateMilliMsat;

@property(nonatomic, readwrite) BOOL disabled;

@property(nonatomic, readwrite) uint64_t maxHtlcMsat;

@property(nonatomic, readwrite) uint32_t lastUpdate;

@end

#pragma mark - ChannelEdge

typedef GPB_ENUM(ChannelEdge_FieldNumber) {
  ChannelEdge_FieldNumber_ChannelId = 1,
  ChannelEdge_FieldNumber_ChanPoint = 2,
  ChannelEdge_FieldNumber_LastUpdate = 3,
  ChannelEdge_FieldNumber_Node1Pub = 4,
  ChannelEdge_FieldNumber_Node2Pub = 5,
  ChannelEdge_FieldNumber_Capacity = 6,
  ChannelEdge_FieldNumber_Node1Policy = 7,
  ChannelEdge_FieldNumber_Node2Policy = 8,
};

/**
 * *
 * A fully authenticated channel along with all its unique attributes.
 * Once an authenticated channel announcement has been processed on the network,
 * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
 * stored. The other portions relevant to routing policy of a channel are stored
 * within a ChannelEdgePolicy for each direction of the channel.
 **/
@interface ChannelEdge : GPBMessage

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t channelId;

@property(nonatomic, readwrite, copy, null_resettable) NSString *chanPoint;

@property(nonatomic, readwrite) uint32_t lastUpdate GPB_DEPRECATED_MSG("lnrpc.ChannelEdge.last_update is deprecated (see rpc.proto).");

@property(nonatomic, readwrite, copy, null_resettable) NSString *node1Pub;

@property(nonatomic, readwrite, copy, null_resettable) NSString *node2Pub;

@property(nonatomic, readwrite) int64_t capacity;

@property(nonatomic, readwrite, strong, null_resettable) RoutingPolicy *node1Policy;
/** Test to see if @c node1Policy has been set. */
@property(nonatomic, readwrite) BOOL hasNode1Policy;

@property(nonatomic, readwrite, strong, null_resettable) RoutingPolicy *node2Policy;
/** Test to see if @c node2Policy has been set. */
@property(nonatomic, readwrite) BOOL hasNode2Policy;

@end

#pragma mark - ChannelGraphRequest

typedef GPB_ENUM(ChannelGraphRequest_FieldNumber) {
  ChannelGraphRequest_FieldNumber_IncludeUnannounced = 1,
};

@interface ChannelGraphRequest : GPBMessage

/**
 * *
 * Whether unannounced channels are included in the response or not. If set,
 * unannounced channels are included. Unannounced channels are both private
 * channels, and public channels that are not yet announced to the network.
 **/
@property(nonatomic, readwrite) BOOL includeUnannounced;

@end

#pragma mark - ChannelGraph

typedef GPB_ENUM(ChannelGraph_FieldNumber) {
  ChannelGraph_FieldNumber_NodesArray = 1,
  ChannelGraph_FieldNumber_EdgesArray = 2,
};

/**
 * / Returns a new instance of the directed channel graph.
 **/
@interface ChannelGraph : GPBMessage

/** / The list of `LightningNode`s in this channel graph */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<LightningNode*> *nodesArray;
/** The number of items in @c nodesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger nodesArray_Count;

/** / The list of `ChannelEdge`s in this channel graph */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelEdge*> *edgesArray;
/** The number of items in @c edgesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger edgesArray_Count;

@end

#pragma mark - NodeMetricsRequest

typedef GPB_ENUM(NodeMetricsRequest_FieldNumber) {
  NodeMetricsRequest_FieldNumber_TypesArray = 1,
};

@interface NodeMetricsRequest : GPBMessage

/** / The requested node metrics. */
// |typesArray| contains |NodeMetricType|
@property(nonatomic, readwrite, strong, null_resettable) GPBEnumArray *typesArray;
/** The number of items in @c typesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger typesArray_Count;

@end

#pragma mark - NodeMetricsResponse

typedef GPB_ENUM(NodeMetricsResponse_FieldNumber) {
  NodeMetricsResponse_FieldNumber_BetweennessCentrality = 1,
};

@interface NodeMetricsResponse : GPBMessage

/**
 * *
 * Betweenness centrality is the sum of the ratio of shortest paths that pass
 * through the node for each pair of nodes in the graph (not counting paths
 * starting or ending at this node).
 * Map of node pubkey to betweenness centrality of the node. Normalized
 * values are in the [0,1] closed interval.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, FloatMetric*> *betweennessCentrality;
/** The number of items in @c betweennessCentrality without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger betweennessCentrality_Count;

@end

#pragma mark - FloatMetric

typedef GPB_ENUM(FloatMetric_FieldNumber) {
  FloatMetric_FieldNumber_Value = 1,
  FloatMetric_FieldNumber_NormalizedValue = 2,
};

@interface FloatMetric : GPBMessage

/** / Arbitrary float value. */
@property(nonatomic, readwrite) double value;

/** / The value normalized to [0,1] or [-1,1]. */
@property(nonatomic, readwrite) double normalizedValue;

@end

#pragma mark - ChanInfoRequest

typedef GPB_ENUM(ChanInfoRequest_FieldNumber) {
  ChanInfoRequest_FieldNumber_ChanId = 1,
};

@interface ChanInfoRequest : GPBMessage

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

@end

#pragma mark - NetworkInfoRequest

@interface NetworkInfoRequest : GPBMessage

@end

#pragma mark - NetworkInfo

typedef GPB_ENUM(NetworkInfo_FieldNumber) {
  NetworkInfo_FieldNumber_GraphDiameter = 1,
  NetworkInfo_FieldNumber_AvgOutDegree = 2,
  NetworkInfo_FieldNumber_MaxOutDegree = 3,
  NetworkInfo_FieldNumber_NumNodes = 4,
  NetworkInfo_FieldNumber_NumChannels = 5,
  NetworkInfo_FieldNumber_TotalNetworkCapacity = 6,
  NetworkInfo_FieldNumber_AvgChannelSize = 7,
  NetworkInfo_FieldNumber_MinChannelSize = 8,
  NetworkInfo_FieldNumber_MaxChannelSize = 9,
  NetworkInfo_FieldNumber_MedianChannelSizeSat = 10,
  NetworkInfo_FieldNumber_NumZombieChans = 11,
};

@interface NetworkInfo : GPBMessage

@property(nonatomic, readwrite) uint32_t graphDiameter;

@property(nonatomic, readwrite) double avgOutDegree;

@property(nonatomic, readwrite) uint32_t maxOutDegree;

@property(nonatomic, readwrite) uint32_t numNodes;

@property(nonatomic, readwrite) uint32_t numChannels;

@property(nonatomic, readwrite) int64_t totalNetworkCapacity;

@property(nonatomic, readwrite) double avgChannelSize;

@property(nonatomic, readwrite) int64_t minChannelSize;

@property(nonatomic, readwrite) int64_t maxChannelSize;

@property(nonatomic, readwrite) int64_t medianChannelSizeSat;

/** The number of edges marked as zombies. */
@property(nonatomic, readwrite) uint64_t numZombieChans;

@end

#pragma mark - StopRequest

@interface StopRequest : GPBMessage

@end

#pragma mark - StopResponse

@interface StopResponse : GPBMessage

@end

#pragma mark - GraphTopologySubscription

@interface GraphTopologySubscription : GPBMessage

@end

#pragma mark - GraphTopologyUpdate

typedef GPB_ENUM(GraphTopologyUpdate_FieldNumber) {
  GraphTopologyUpdate_FieldNumber_NodeUpdatesArray = 1,
  GraphTopologyUpdate_FieldNumber_ChannelUpdatesArray = 2,
  GraphTopologyUpdate_FieldNumber_ClosedChansArray = 3,
};

@interface GraphTopologyUpdate : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NodeUpdate*> *nodeUpdatesArray;
/** The number of items in @c nodeUpdatesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger nodeUpdatesArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelEdgeUpdate*> *channelUpdatesArray;
/** The number of items in @c channelUpdatesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger channelUpdatesArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ClosedChannelUpdate*> *closedChansArray;
/** The number of items in @c closedChansArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger closedChansArray_Count;

@end

#pragma mark - NodeUpdate

typedef GPB_ENUM(NodeUpdate_FieldNumber) {
  NodeUpdate_FieldNumber_AddressesArray = 1,
  NodeUpdate_FieldNumber_IdentityKey = 2,
  NodeUpdate_FieldNumber_GlobalFeatures = 3,
  NodeUpdate_FieldNumber_Alias = 4,
  NodeUpdate_FieldNumber_Color = 5,
};

@interface NodeUpdate : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *addressesArray;
/** The number of items in @c addressesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger addressesArray_Count;

@property(nonatomic, readwrite, copy, null_resettable) NSString *identityKey;

@property(nonatomic, readwrite, copy, null_resettable) NSData *globalFeatures;

@property(nonatomic, readwrite, copy, null_resettable) NSString *alias;

@property(nonatomic, readwrite, copy, null_resettable) NSString *color;

@end

#pragma mark - ChannelEdgeUpdate

typedef GPB_ENUM(ChannelEdgeUpdate_FieldNumber) {
  ChannelEdgeUpdate_FieldNumber_ChanId = 1,
  ChannelEdgeUpdate_FieldNumber_ChanPoint = 2,
  ChannelEdgeUpdate_FieldNumber_Capacity = 3,
  ChannelEdgeUpdate_FieldNumber_RoutingPolicy = 4,
  ChannelEdgeUpdate_FieldNumber_AdvertisingNode = 5,
  ChannelEdgeUpdate_FieldNumber_ConnectingNode = 6,
};

@interface ChannelEdgeUpdate : GPBMessage

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;
/** Test to see if @c chanPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChanPoint;

@property(nonatomic, readwrite) int64_t capacity;

@property(nonatomic, readwrite, strong, null_resettable) RoutingPolicy *routingPolicy;
/** Test to see if @c routingPolicy has been set. */
@property(nonatomic, readwrite) BOOL hasRoutingPolicy;

@property(nonatomic, readwrite, copy, null_resettable) NSString *advertisingNode;

@property(nonatomic, readwrite, copy, null_resettable) NSString *connectingNode;

@end

#pragma mark - ClosedChannelUpdate

typedef GPB_ENUM(ClosedChannelUpdate_FieldNumber) {
  ClosedChannelUpdate_FieldNumber_ChanId = 1,
  ClosedChannelUpdate_FieldNumber_Capacity = 2,
  ClosedChannelUpdate_FieldNumber_ClosedHeight = 3,
  ClosedChannelUpdate_FieldNumber_ChanPoint = 4,
};

@interface ClosedChannelUpdate : GPBMessage

/**
 * *
 * The unique channel ID for the channel. The first 3 bytes are the block
 * height, the next 3 the index within the block, and the last 2 bytes are the
 * output index for the channel.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

@property(nonatomic, readwrite) int64_t capacity;

@property(nonatomic, readwrite) uint32_t closedHeight;

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;
/** Test to see if @c chanPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChanPoint;

@end

#pragma mark - HopHint

typedef GPB_ENUM(HopHint_FieldNumber) {
  HopHint_FieldNumber_NodeId = 1,
  HopHint_FieldNumber_ChanId = 2,
  HopHint_FieldNumber_FeeBaseMsat = 3,
  HopHint_FieldNumber_FeeProportionalMillionths = 4,
  HopHint_FieldNumber_CltvExpiryDelta = 5,
};

@interface HopHint : GPBMessage

/** / The public key of the node at the start of the channel. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *nodeId;

/** / The unique identifier of the channel. */
@property(nonatomic, readwrite) uint64_t chanId;

/** / The base fee of the channel denominated in millisatoshis. */
@property(nonatomic, readwrite) uint32_t feeBaseMsat;

/**
 * *
 * The fee rate of the channel for sending one satoshi across it denominated in
 * millionths of a satoshi.
 **/
@property(nonatomic, readwrite) uint32_t feeProportionalMillionths;

/** / The time-lock delta of the channel. */
@property(nonatomic, readwrite) uint32_t cltvExpiryDelta;

@end

#pragma mark - RouteHint

typedef GPB_ENUM(RouteHint_FieldNumber) {
  RouteHint_FieldNumber_HopHintsArray = 1,
};

@interface RouteHint : GPBMessage

/**
 * *
 * A list of hop hints that when chained together can assist in reaching a
 * specific destination.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<HopHint*> *hopHintsArray;
/** The number of items in @c hopHintsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger hopHintsArray_Count;

@end

#pragma mark - Invoice

typedef GPB_ENUM(Invoice_FieldNumber) {
  Invoice_FieldNumber_Memo = 1,
  Invoice_FieldNumber_RPreimage = 3,
  Invoice_FieldNumber_RHash = 4,
  Invoice_FieldNumber_Value = 5,
  Invoice_FieldNumber_Settled = 6,
  Invoice_FieldNumber_CreationDate = 7,
  Invoice_FieldNumber_SettleDate = 8,
  Invoice_FieldNumber_PaymentRequest = 9,
  Invoice_FieldNumber_DescriptionHash = 10,
  Invoice_FieldNumber_Expiry = 11,
  Invoice_FieldNumber_FallbackAddr = 12,
  Invoice_FieldNumber_CltvExpiry = 13,
  Invoice_FieldNumber_RouteHintsArray = 14,
  Invoice_FieldNumber_Private_p = 15,
  Invoice_FieldNumber_AddIndex = 16,
  Invoice_FieldNumber_SettleIndex = 17,
  Invoice_FieldNumber_AmtPaid = 18,
  Invoice_FieldNumber_AmtPaidSat = 19,
  Invoice_FieldNumber_AmtPaidMsat = 20,
  Invoice_FieldNumber_State = 21,
  Invoice_FieldNumber_HtlcsArray = 22,
  Invoice_FieldNumber_ValueMsat = 23,
  Invoice_FieldNumber_Features = 24,
  Invoice_FieldNumber_IsKeysend = 25,
};

@interface Invoice : GPBMessage

/**
 * *
 * An optional memo to attach along with the invoice. Used for record keeping
 * purposes for the invoice's creator, and will also be set in the description
 * field of the encoded payment request if the description_hash field is not
 * being used.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *memo;

/**
 * *
 * The hex-encoded preimage (32 byte) which will allow settling an incoming
 * HTLC payable to this preimage. When using REST, this field must be encoded
 * as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *rPreimage;

/**
 * *
 * The hash of the preimage. When using REST, this field must be encoded as
 * base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *rHash;

/**
 * *
 * The value of this invoice in satoshis
 *
 * The fields value and value_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t value;

/**
 * *
 * The value of this invoice in millisatoshis
 *
 * The fields value and value_msat are mutually exclusive.
 **/
@property(nonatomic, readwrite) int64_t valueMsat;

/** / Whether this invoice has been fulfilled */
@property(nonatomic, readwrite) BOOL settled GPB_DEPRECATED_MSG("lnrpc.Invoice.settled is deprecated (see rpc.proto).");

/** / When this invoice was created */
@property(nonatomic, readwrite) int64_t creationDate;

/** / When this invoice was settled */
@property(nonatomic, readwrite) int64_t settleDate;

/**
 * *
 * A bare-bones invoice for a payment within the Lightning Network. With the
 * details of the invoice, the sender has all the data necessary to send a
 * payment to the recipient.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentRequest;

/**
 * *
 * Hash (SHA-256) of a description of the payment. Used if the description of
 * payment (memo) is too long to naturally fit within the description field
 * of an encoded payment request. When using REST, this field must be encoded
 * as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *descriptionHash;

/** / Payment request expiry time in seconds. Default is 3600 (1 hour). */
@property(nonatomic, readwrite) int64_t expiry;

/** / Fallback on-chain address. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *fallbackAddr;

/** / Delta to use for the time-lock of the CLTV extended to the final hop. */
@property(nonatomic, readwrite) uint64_t cltvExpiry;

/**
 * *
 * Route hints that can each be individually used to assist in reaching the
 * invoice's destination.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<RouteHint*> *routeHintsArray;
/** The number of items in @c routeHintsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger routeHintsArray_Count;

/** / Whether this invoice should include routing hints for private channels. */
@property(nonatomic, readwrite) BOOL private_p;

/**
 * *
 * The "add" index of this invoice. Each newly created invoice will increment
 * this index making it monotonically increasing. Callers to the
 * SubscribeInvoices call can use this to instantly get notified of all added
 * invoices with an add_index greater than this one.
 **/
@property(nonatomic, readwrite) uint64_t addIndex;

/**
 * *
 * The "settle" index of this invoice. Each newly settled invoice will
 * increment this index making it monotonically increasing. Callers to the
 * SubscribeInvoices call can use this to instantly get notified of all
 * settled invoices with an settle_index greater than this one.
 **/
@property(nonatomic, readwrite) uint64_t settleIndex;

/** / Deprecated, use amt_paid_sat or amt_paid_msat. */
@property(nonatomic, readwrite) int64_t amtPaid GPB_DEPRECATED_MSG("lnrpc.Invoice.amt_paid is deprecated (see rpc.proto).");

/**
 * *
 * The amount that was accepted for this invoice, in satoshis. This will ONLY
 * be set if this invoice has been settled. We provide this field as if the
 * invoice was created with a zero value, then we need to record what amount
 * was ultimately accepted. Additionally, it's possible that the sender paid
 * MORE that was specified in the original invoice. So we'll record that here
 * as well.
 **/
@property(nonatomic, readwrite) int64_t amtPaidSat;

/**
 * *
 * The amount that was accepted for this invoice, in millisatoshis. This will
 * ONLY be set if this invoice has been settled. We provide this field as if
 * the invoice was created with a zero value, then we need to record what
 * amount was ultimately accepted. Additionally, it's possible that the sender
 * paid MORE that was specified in the original invoice. So we'll record that
 * here as well.
 **/
@property(nonatomic, readwrite) int64_t amtPaidMsat;

/**
 * *
 * The state the invoice is in.
 **/
@property(nonatomic, readwrite) Invoice_InvoiceState state;

/** / List of HTLCs paying to this invoice [EXPERIMENTAL]. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<InvoiceHTLC*> *htlcsArray;
/** The number of items in @c htlcsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger htlcsArray_Count;

/** / List of features advertised on the invoice. */
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32ObjectDictionary<Feature*> *features;
/** The number of items in @c features without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger features_Count;

/**
 * *
 * Indicates if this invoice was a spontaneous payment that arrived via keysend
 * [EXPERIMENTAL].
 **/
@property(nonatomic, readwrite) BOOL isKeysend;

@end

/**
 * Fetches the raw value of a @c Invoice's @c state property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Invoice_State_RawValue(Invoice *message);
/**
 * Sets the raw value of an @c Invoice's @c state property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetInvoice_State_RawValue(Invoice *message, int32_t value);

#pragma mark - InvoiceHTLC

typedef GPB_ENUM(InvoiceHTLC_FieldNumber) {
  InvoiceHTLC_FieldNumber_ChanId = 1,
  InvoiceHTLC_FieldNumber_HtlcIndex = 2,
  InvoiceHTLC_FieldNumber_AmtMsat = 3,
  InvoiceHTLC_FieldNumber_AcceptHeight = 4,
  InvoiceHTLC_FieldNumber_AcceptTime = 5,
  InvoiceHTLC_FieldNumber_ResolveTime = 6,
  InvoiceHTLC_FieldNumber_ExpiryHeight = 7,
  InvoiceHTLC_FieldNumber_State = 8,
  InvoiceHTLC_FieldNumber_CustomRecords = 9,
  InvoiceHTLC_FieldNumber_MppTotalAmtMsat = 10,
};

/**
 * / Details of an HTLC that paid to an invoice
 **/
@interface InvoiceHTLC : GPBMessage

/** / Short channel id over which the htlc was received. */
@property(nonatomic, readwrite) uint64_t chanId;

/** / Index identifying the htlc on the channel. */
@property(nonatomic, readwrite) uint64_t htlcIndex;

/** / The amount of the htlc in msat. */
@property(nonatomic, readwrite) uint64_t amtMsat;

/** / Block height at which this htlc was accepted. */
@property(nonatomic, readwrite) int32_t acceptHeight;

/** / Time at which this htlc was accepted. */
@property(nonatomic, readwrite) int64_t acceptTime;

/** / Time at which this htlc was settled or canceled. */
@property(nonatomic, readwrite) int64_t resolveTime;

/** / Block height at which this htlc expires. */
@property(nonatomic, readwrite) int32_t expiryHeight;

/** / Current state the htlc is in. */
@property(nonatomic, readwrite) InvoiceHTLCState state;

/** / Custom tlv records. */
@property(nonatomic, readwrite, strong, null_resettable) GPBUInt64ObjectDictionary<NSData*> *customRecords;
/** The number of items in @c customRecords without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger customRecords_Count;

/** / The total amount of the mpp payment in msat. */
@property(nonatomic, readwrite) uint64_t mppTotalAmtMsat;

@end

/**
 * Fetches the raw value of a @c InvoiceHTLC's @c state property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t InvoiceHTLC_State_RawValue(InvoiceHTLC *message);
/**
 * Sets the raw value of an @c InvoiceHTLC's @c state property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetInvoiceHTLC_State_RawValue(InvoiceHTLC *message, int32_t value);

#pragma mark - AddInvoiceResponse

typedef GPB_ENUM(AddInvoiceResponse_FieldNumber) {
  AddInvoiceResponse_FieldNumber_RHash = 1,
  AddInvoiceResponse_FieldNumber_PaymentRequest = 2,
  AddInvoiceResponse_FieldNumber_AddIndex = 16,
};

@interface AddInvoiceResponse : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *rHash;

/**
 * *
 * A bare-bones invoice for a payment within the Lightning Network. With the
 * details of the invoice, the sender has all the data necessary to send a
 * payment to the recipient.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentRequest;

/**
 * *
 * The "add" index of this invoice. Each newly created invoice will increment
 * this index making it monotonically increasing. Callers to the
 * SubscribeInvoices call can use this to instantly get notified of all added
 * invoices with an add_index greater than this one.
 **/
@property(nonatomic, readwrite) uint64_t addIndex;

@end

#pragma mark - PaymentHash

typedef GPB_ENUM(PaymentHash_FieldNumber) {
  PaymentHash_FieldNumber_RHashStr = 1,
  PaymentHash_FieldNumber_RHash = 2,
};

@interface PaymentHash : GPBMessage

/**
 * *
 * The hex-encoded payment hash of the invoice to be looked up. The passed
 * payment hash must be exactly 32 bytes, otherwise an error is returned.
 * Deprecated now that the REST gateway supports base64 encoding of bytes
 * fields.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *rHashStr GPB_DEPRECATED_MSG("lnrpc.PaymentHash.r_hash_str is deprecated (see rpc.proto).");

/**
 * *
 * The payment hash of the invoice to be looked up. When using REST, this field
 * must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *rHash;

@end

#pragma mark - ListInvoiceRequest

typedef GPB_ENUM(ListInvoiceRequest_FieldNumber) {
  ListInvoiceRequest_FieldNumber_PendingOnly = 1,
  ListInvoiceRequest_FieldNumber_IndexOffset = 4,
  ListInvoiceRequest_FieldNumber_NumMaxInvoices = 5,
  ListInvoiceRequest_FieldNumber_Reversed = 6,
};

@interface ListInvoiceRequest : GPBMessage

/**
 * *
 * If set, only invoices that are not settled and not canceled will be returned
 * in the response.
 **/
@property(nonatomic, readwrite) BOOL pendingOnly;

/**
 * *
 * The index of an invoice that will be used as either the start or end of a
 * query to determine which invoices should be returned in the response.
 **/
@property(nonatomic, readwrite) uint64_t indexOffset;

/** / The max number of invoices to return in the response to this query. */
@property(nonatomic, readwrite) uint64_t numMaxInvoices;

/**
 * *
 * If set, the invoices returned will result from seeking backwards from the
 * specified index offset. This can be used to paginate backwards.
 **/
@property(nonatomic, readwrite) BOOL reversed;

@end

#pragma mark - ListInvoiceResponse

typedef GPB_ENUM(ListInvoiceResponse_FieldNumber) {
  ListInvoiceResponse_FieldNumber_InvoicesArray = 1,
  ListInvoiceResponse_FieldNumber_LastIndexOffset = 2,
  ListInvoiceResponse_FieldNumber_FirstIndexOffset = 3,
};

@interface ListInvoiceResponse : GPBMessage

/**
 * *
 * A list of invoices from the time slice of the time series specified in the
 * request.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Invoice*> *invoicesArray;
/** The number of items in @c invoicesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger invoicesArray_Count;

/**
 * *
 * The index of the last item in the set of returned invoices. This can be used
 * to seek further, pagination style.
 **/
@property(nonatomic, readwrite) uint64_t lastIndexOffset;

/**
 * *
 * The index of the last item in the set of returned invoices. This can be used
 * to seek backwards, pagination style.
 **/
@property(nonatomic, readwrite) uint64_t firstIndexOffset;

@end

#pragma mark - InvoiceSubscription

typedef GPB_ENUM(InvoiceSubscription_FieldNumber) {
  InvoiceSubscription_FieldNumber_AddIndex = 1,
  InvoiceSubscription_FieldNumber_SettleIndex = 2,
};

@interface InvoiceSubscription : GPBMessage

/**
 * *
 * If specified (non-zero), then we'll first start by sending out
 * notifications for all added indexes with an add_index greater than this
 * value. This allows callers to catch up on any events they missed while they
 * weren't connected to the streaming RPC.
 **/
@property(nonatomic, readwrite) uint64_t addIndex;

/**
 * *
 * If specified (non-zero), then we'll first start by sending out
 * notifications for all settled indexes with an settle_index greater than
 * this value. This allows callers to catch up on any events they missed while
 * they weren't connected to the streaming RPC.
 **/
@property(nonatomic, readwrite) uint64_t settleIndex;

@end

#pragma mark - Payment

typedef GPB_ENUM(Payment_FieldNumber) {
  Payment_FieldNumber_PaymentHash = 1,
  Payment_FieldNumber_Value = 2,
  Payment_FieldNumber_CreationDate = 3,
  Payment_FieldNumber_Fee = 5,
  Payment_FieldNumber_PaymentPreimage = 6,
  Payment_FieldNumber_ValueSat = 7,
  Payment_FieldNumber_ValueMsat = 8,
  Payment_FieldNumber_PaymentRequest = 9,
  Payment_FieldNumber_Status = 10,
  Payment_FieldNumber_FeeSat = 11,
  Payment_FieldNumber_FeeMsat = 12,
  Payment_FieldNumber_CreationTimeNs = 13,
  Payment_FieldNumber_HtlcsArray = 14,
  Payment_FieldNumber_PaymentIndex = 15,
  Payment_FieldNumber_FailureReason = 16,
};

@interface Payment : GPBMessage

/** / The payment hash */
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentHash;

/** / Deprecated, use value_sat or value_msat. */
@property(nonatomic, readwrite) int64_t value GPB_DEPRECATED_MSG("lnrpc.Payment.value is deprecated (see rpc.proto).");

/** / Deprecated, use creation_time_ns */
@property(nonatomic, readwrite) int64_t creationDate GPB_DEPRECATED_MSG("lnrpc.Payment.creation_date is deprecated (see rpc.proto).");

/** / Deprecated, use fee_sat or fee_msat. */
@property(nonatomic, readwrite) int64_t fee GPB_DEPRECATED_MSG("lnrpc.Payment.fee is deprecated (see rpc.proto).");

/** / The payment preimage */
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentPreimage;

/** / The value of the payment in satoshis */
@property(nonatomic, readwrite) int64_t valueSat;

/** / The value of the payment in milli-satoshis */
@property(nonatomic, readwrite) int64_t valueMsat;

/** / The optional payment request being fulfilled. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentRequest;

/** The status of the payment. */
@property(nonatomic, readwrite) Payment_PaymentStatus status;

/** /  The fee paid for this payment in satoshis */
@property(nonatomic, readwrite) int64_t feeSat;

/** /  The fee paid for this payment in milli-satoshis */
@property(nonatomic, readwrite) int64_t feeMsat;

/** / The time in UNIX nanoseconds at which the payment was created. */
@property(nonatomic, readwrite) int64_t creationTimeNs;

/** / The HTLCs made in attempt to settle the payment. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<HTLCAttempt*> *htlcsArray;
/** The number of items in @c htlcsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger htlcsArray_Count;

/**
 * *
 * The creation index of this payment. Each payment can be uniquely identified
 * by this index, which may not strictly increment by 1 for payments made in
 * older versions of lnd.
 **/
@property(nonatomic, readwrite) uint64_t paymentIndex;

@property(nonatomic, readwrite) PaymentFailureReason failureReason;

@end

/**
 * Fetches the raw value of a @c Payment's @c status property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Payment_Status_RawValue(Payment *message);
/**
 * Sets the raw value of an @c Payment's @c status property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPayment_Status_RawValue(Payment *message, int32_t value);

/**
 * Fetches the raw value of a @c Payment's @c failureReason property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Payment_FailureReason_RawValue(Payment *message);
/**
 * Sets the raw value of an @c Payment's @c failureReason property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPayment_FailureReason_RawValue(Payment *message, int32_t value);

#pragma mark - HTLCAttempt

typedef GPB_ENUM(HTLCAttempt_FieldNumber) {
  HTLCAttempt_FieldNumber_Status = 1,
  HTLCAttempt_FieldNumber_Route = 2,
  HTLCAttempt_FieldNumber_AttemptTimeNs = 3,
  HTLCAttempt_FieldNumber_ResolveTimeNs = 4,
  HTLCAttempt_FieldNumber_Failure = 5,
};

@interface HTLCAttempt : GPBMessage

/** / The status of the HTLC. */
@property(nonatomic, readwrite) HTLCAttempt_HTLCStatus status;

/** / The route taken by this HTLC. */
@property(nonatomic, readwrite, strong, null_resettable) Route *route;
/** Test to see if @c route has been set. */
@property(nonatomic, readwrite) BOOL hasRoute;

/** / The time in UNIX nanoseconds at which this HTLC was sent. */
@property(nonatomic, readwrite) int64_t attemptTimeNs;

/**
 * *
 * The time in UNIX nanoseconds at which this HTLC was settled or failed.
 * This value will not be set if the HTLC is still IN_FLIGHT.
 **/
@property(nonatomic, readwrite) int64_t resolveTimeNs;

/** Detailed htlc failure info. */
@property(nonatomic, readwrite, strong, null_resettable) Failure *failure;
/** Test to see if @c failure has been set. */
@property(nonatomic, readwrite) BOOL hasFailure;

@end

/**
 * Fetches the raw value of a @c HTLCAttempt's @c status property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t HTLCAttempt_Status_RawValue(HTLCAttempt *message);
/**
 * Sets the raw value of an @c HTLCAttempt's @c status property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetHTLCAttempt_Status_RawValue(HTLCAttempt *message, int32_t value);

#pragma mark - ListPaymentsRequest

typedef GPB_ENUM(ListPaymentsRequest_FieldNumber) {
  ListPaymentsRequest_FieldNumber_IncludeIncomplete = 1,
  ListPaymentsRequest_FieldNumber_IndexOffset = 2,
  ListPaymentsRequest_FieldNumber_MaxPayments = 3,
  ListPaymentsRequest_FieldNumber_Reversed = 4,
};

@interface ListPaymentsRequest : GPBMessage

/**
 * *
 * If true, then return payments that have not yet fully completed. This means
 * that pending payments, as well as failed payments will show up if this
 * field is set to true. This flag doesn't change the meaning of the indices,
 * which are tied to individual payments.
 **/
@property(nonatomic, readwrite) BOOL includeIncomplete;

/**
 * *
 * The index of a payment that will be used as either the start or end of a
 * query to determine which payments should be returned in the response. The
 * index_offset is exclusive. In the case of a zero index_offset, the query
 * will start with the oldest payment when paginating forwards, or will end
 * with the most recent payment when paginating backwards.
 **/
@property(nonatomic, readwrite) uint64_t indexOffset;

/** / The maximal number of payments returned in the response to this query. */
@property(nonatomic, readwrite) uint64_t maxPayments;

/**
 * *
 * If set, the payments returned will result from seeking backwards from the
 * specified index offset. This can be used to paginate backwards. The order
 * of the returned payments is always oldest first (ascending index order).
 **/
@property(nonatomic, readwrite) BOOL reversed;

@end

#pragma mark - ListPaymentsResponse

typedef GPB_ENUM(ListPaymentsResponse_FieldNumber) {
  ListPaymentsResponse_FieldNumber_PaymentsArray = 1,
  ListPaymentsResponse_FieldNumber_FirstIndexOffset = 2,
  ListPaymentsResponse_FieldNumber_LastIndexOffset = 3,
};

@interface ListPaymentsResponse : GPBMessage

/** / The list of payments */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Payment*> *paymentsArray;
/** The number of items in @c paymentsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger paymentsArray_Count;

/**
 * *
 * The index of the first item in the set of returned payments. This can be
 * used as the index_offset to continue seeking backwards in the next request.
 **/
@property(nonatomic, readwrite) uint64_t firstIndexOffset;

/**
 * *
 * The index of the last item in the set of returned payments. This can be used
 * as the index_offset to continue seeking forwards in the next request.
 **/
@property(nonatomic, readwrite) uint64_t lastIndexOffset;

@end

#pragma mark - DeleteAllPaymentsRequest

@interface DeleteAllPaymentsRequest : GPBMessage

@end

#pragma mark - DeleteAllPaymentsResponse

@interface DeleteAllPaymentsResponse : GPBMessage

@end

#pragma mark - AbandonChannelRequest

typedef GPB_ENUM(AbandonChannelRequest_FieldNumber) {
  AbandonChannelRequest_FieldNumber_ChannelPoint = 1,
};

@interface AbandonChannelRequest : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *channelPoint;
/** Test to see if @c channelPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChannelPoint;

@end

#pragma mark - AbandonChannelResponse

@interface AbandonChannelResponse : GPBMessage

@end

#pragma mark - DebugLevelRequest

typedef GPB_ENUM(DebugLevelRequest_FieldNumber) {
  DebugLevelRequest_FieldNumber_Show = 1,
  DebugLevelRequest_FieldNumber_LevelSpec = 2,
};

@interface DebugLevelRequest : GPBMessage

@property(nonatomic, readwrite) BOOL show;

@property(nonatomic, readwrite, copy, null_resettable) NSString *levelSpec;

@end

#pragma mark - DebugLevelResponse

typedef GPB_ENUM(DebugLevelResponse_FieldNumber) {
  DebugLevelResponse_FieldNumber_SubSystems = 1,
};

@interface DebugLevelResponse : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *subSystems;

@end

#pragma mark - PayReqString

typedef GPB_ENUM(PayReqString_FieldNumber) {
  PayReqString_FieldNumber_PayReq = 1,
};

@interface PayReqString : GPBMessage

/** / The payment request string to be decoded */
@property(nonatomic, readwrite, copy, null_resettable) NSString *payReq;

@end

#pragma mark - PayReq

typedef GPB_ENUM(PayReq_FieldNumber) {
  PayReq_FieldNumber_Destination = 1,
  PayReq_FieldNumber_PaymentHash = 2,
  PayReq_FieldNumber_NumSatoshis = 3,
  PayReq_FieldNumber_Timestamp = 4,
  PayReq_FieldNumber_Expiry = 5,
  PayReq_FieldNumber_Description_p = 6,
  PayReq_FieldNumber_DescriptionHash = 7,
  PayReq_FieldNumber_FallbackAddr = 8,
  PayReq_FieldNumber_CltvExpiry = 9,
  PayReq_FieldNumber_RouteHintsArray = 10,
  PayReq_FieldNumber_PaymentAddr = 11,
  PayReq_FieldNumber_NumMsat = 12,
  PayReq_FieldNumber_Features = 13,
};

@interface PayReq : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *destination;

@property(nonatomic, readwrite, copy, null_resettable) NSString *paymentHash;

@property(nonatomic, readwrite) int64_t numSatoshis;

@property(nonatomic, readwrite) int64_t timestamp;

@property(nonatomic, readwrite) int64_t expiry;

@property(nonatomic, readwrite, copy, null_resettable) NSString *description_p;

@property(nonatomic, readwrite, copy, null_resettable) NSString *descriptionHash;

@property(nonatomic, readwrite, copy, null_resettable) NSString *fallbackAddr;

@property(nonatomic, readwrite) int64_t cltvExpiry;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<RouteHint*> *routeHintsArray;
/** The number of items in @c routeHintsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger routeHintsArray_Count;

@property(nonatomic, readwrite, copy, null_resettable) NSData *paymentAddr;

@property(nonatomic, readwrite) int64_t numMsat;

@property(nonatomic, readwrite, strong, null_resettable) GPBUInt32ObjectDictionary<Feature*> *features;
/** The number of items in @c features without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger features_Count;

@end

#pragma mark - Feature

typedef GPB_ENUM(Feature_FieldNumber) {
  Feature_FieldNumber_Name = 2,
  Feature_FieldNumber_IsRequired = 3,
  Feature_FieldNumber_IsKnown = 4,
};

@interface Feature : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

@property(nonatomic, readwrite) BOOL isRequired;

@property(nonatomic, readwrite) BOOL isKnown;

@end

#pragma mark - FeeReportRequest

@interface FeeReportRequest : GPBMessage

@end

#pragma mark - ChannelFeeReport

typedef GPB_ENUM(ChannelFeeReport_FieldNumber) {
  ChannelFeeReport_FieldNumber_ChannelPoint = 1,
  ChannelFeeReport_FieldNumber_BaseFeeMsat = 2,
  ChannelFeeReport_FieldNumber_FeePerMil = 3,
  ChannelFeeReport_FieldNumber_FeeRate = 4,
  ChannelFeeReport_FieldNumber_ChanId = 5,
};

@interface ChannelFeeReport : GPBMessage

/** / The short channel id that this fee report belongs to. */
@property(nonatomic, readwrite) uint64_t chanId;

/** / The channel that this fee report belongs to. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelPoint;

/** / The base fee charged regardless of the number of milli-satoshis sent. */
@property(nonatomic, readwrite) int64_t baseFeeMsat;

/**
 * / The amount charged per milli-satoshis transferred expressed in
 * / millionths of a satoshi.
 **/
@property(nonatomic, readwrite) int64_t feePerMil;

/**
 * / The effective fee rate in milli-satoshis. Computed by dividing the
 * / fee_per_mil value by 1 million.
 **/
@property(nonatomic, readwrite) double feeRate;

@end

#pragma mark - FeeReportResponse

typedef GPB_ENUM(FeeReportResponse_FieldNumber) {
  FeeReportResponse_FieldNumber_ChannelFeesArray = 1,
  FeeReportResponse_FieldNumber_DayFeeSum = 2,
  FeeReportResponse_FieldNumber_WeekFeeSum = 3,
  FeeReportResponse_FieldNumber_MonthFeeSum = 4,
};

@interface FeeReportResponse : GPBMessage

/**
 * / An array of channel fee reports which describes the current fee schedule
 * / for each channel.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelFeeReport*> *channelFeesArray;
/** The number of items in @c channelFeesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger channelFeesArray_Count;

/**
 * / The total amount of fee revenue (in satoshis) the switch has collected
 * / over the past 24 hrs.
 **/
@property(nonatomic, readwrite) uint64_t dayFeeSum;

/**
 * / The total amount of fee revenue (in satoshis) the switch has collected
 * / over the past 1 week.
 **/
@property(nonatomic, readwrite) uint64_t weekFeeSum;

/**
 * / The total amount of fee revenue (in satoshis) the switch has collected
 * / over the past 1 month.
 **/
@property(nonatomic, readwrite) uint64_t monthFeeSum;

@end

#pragma mark - PolicyUpdateRequest

typedef GPB_ENUM(PolicyUpdateRequest_FieldNumber) {
  PolicyUpdateRequest_FieldNumber_Global = 1,
  PolicyUpdateRequest_FieldNumber_ChanPoint = 2,
  PolicyUpdateRequest_FieldNumber_BaseFeeMsat = 3,
  PolicyUpdateRequest_FieldNumber_FeeRate = 4,
  PolicyUpdateRequest_FieldNumber_TimeLockDelta = 5,
  PolicyUpdateRequest_FieldNumber_MaxHtlcMsat = 6,
  PolicyUpdateRequest_FieldNumber_MinHtlcMsat = 7,
  PolicyUpdateRequest_FieldNumber_MinHtlcMsatSpecified = 8,
};

typedef GPB_ENUM(PolicyUpdateRequest_Scope_OneOfCase) {
  PolicyUpdateRequest_Scope_OneOfCase_GPBUnsetOneOfCase = 0,
  PolicyUpdateRequest_Scope_OneOfCase_Global = 1,
  PolicyUpdateRequest_Scope_OneOfCase_ChanPoint = 2,
};

@interface PolicyUpdateRequest : GPBMessage

@property(nonatomic, readonly) PolicyUpdateRequest_Scope_OneOfCase scopeOneOfCase;

/** / If set, then this update applies to all currently active channels. */
@property(nonatomic, readwrite) BOOL global;

/** / If set, this update will target a specific channel. */
@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;

/** / The base fee charged regardless of the number of milli-satoshis sent. */
@property(nonatomic, readwrite) int64_t baseFeeMsat;

/**
 * / The effective fee rate in milli-satoshis. The precision of this value
 * / goes up to 6 decimal places, so 1e-6.
 **/
@property(nonatomic, readwrite) double feeRate;

/** / The required timelock delta for HTLCs forwarded over the channel. */
@property(nonatomic, readwrite) uint32_t timeLockDelta;

/**
 * / If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
 * / HTLC will be unchanged.
 **/
@property(nonatomic, readwrite) uint64_t maxHtlcMsat;

/**
 * / The minimum HTLC size in milli-satoshis. Only applied if
 * / min_htlc_msat_specified is true.
 **/
@property(nonatomic, readwrite) uint64_t minHtlcMsat;

/** / If true, min_htlc_msat is applied. */
@property(nonatomic, readwrite) BOOL minHtlcMsatSpecified;

@end

/**
 * Clears whatever value was set for the oneof 'scope'.
 **/
void PolicyUpdateRequest_ClearScopeOneOfCase(PolicyUpdateRequest *message);

#pragma mark - PolicyUpdateResponse

@interface PolicyUpdateResponse : GPBMessage

@end

#pragma mark - ForwardingHistoryRequest

typedef GPB_ENUM(ForwardingHistoryRequest_FieldNumber) {
  ForwardingHistoryRequest_FieldNumber_StartTime = 1,
  ForwardingHistoryRequest_FieldNumber_EndTime = 2,
  ForwardingHistoryRequest_FieldNumber_IndexOffset = 3,
  ForwardingHistoryRequest_FieldNumber_NumMaxEvents = 4,
};

@interface ForwardingHistoryRequest : GPBMessage

/**
 * / Start time is the starting point of the forwarding history request. All
 * / records beyond this point will be included, respecting the end time, and
 * / the index offset.
 **/
@property(nonatomic, readwrite) uint64_t startTime;

/**
 * / End time is the end point of the forwarding history request. The
 * / response will carry at most 50k records between the start time and the
 * / end time. The index offset can be used to implement pagination.
 **/
@property(nonatomic, readwrite) uint64_t endTime;

/**
 * / Index offset is the offset in the time series to start at. As each
 * / response can only contain 50k records, callers can use this to skip
 * / around within a packed time series.
 **/
@property(nonatomic, readwrite) uint32_t indexOffset;

/** / The max number of events to return in the response to this query. */
@property(nonatomic, readwrite) uint32_t numMaxEvents;

@end

#pragma mark - ForwardingEvent

typedef GPB_ENUM(ForwardingEvent_FieldNumber) {
  ForwardingEvent_FieldNumber_Timestamp = 1,
  ForwardingEvent_FieldNumber_ChanIdIn = 2,
  ForwardingEvent_FieldNumber_ChanIdOut = 4,
  ForwardingEvent_FieldNumber_AmtIn = 5,
  ForwardingEvent_FieldNumber_AmtOut = 6,
  ForwardingEvent_FieldNumber_Fee = 7,
  ForwardingEvent_FieldNumber_FeeMsat = 8,
  ForwardingEvent_FieldNumber_AmtInMsat = 9,
  ForwardingEvent_FieldNumber_AmtOutMsat = 10,
};

@interface ForwardingEvent : GPBMessage

/**
 * / Timestamp is the time (unix epoch offset) that this circuit was
 * / completed.
 **/
@property(nonatomic, readwrite) uint64_t timestamp;

/** / The incoming channel ID that carried the HTLC that created the circuit. */
@property(nonatomic, readwrite) uint64_t chanIdIn;

/**
 * / The outgoing channel ID that carried the preimage that completed the
 * / circuit.
 **/
@property(nonatomic, readwrite) uint64_t chanIdOut;

/**
 * / The total amount (in satoshis) of the incoming HTLC that created half
 * / the circuit.
 **/
@property(nonatomic, readwrite) uint64_t amtIn;

/**
 * / The total amount (in satoshis) of the outgoing HTLC that created the
 * / second half of the circuit.
 **/
@property(nonatomic, readwrite) uint64_t amtOut;

/** / The total fee (in satoshis) that this payment circuit carried. */
@property(nonatomic, readwrite) uint64_t fee;

/** / The total fee (in milli-satoshis) that this payment circuit carried. */
@property(nonatomic, readwrite) uint64_t feeMsat;

/**
 * / The total amount (in milli-satoshis) of the incoming HTLC that created
 * / half the circuit.
 **/
@property(nonatomic, readwrite) uint64_t amtInMsat;

/**
 * / The total amount (in milli-satoshis) of the outgoing HTLC that created
 * / the second half of the circuit.
 **/
@property(nonatomic, readwrite) uint64_t amtOutMsat;

@end

#pragma mark - ForwardingHistoryResponse

typedef GPB_ENUM(ForwardingHistoryResponse_FieldNumber) {
  ForwardingHistoryResponse_FieldNumber_ForwardingEventsArray = 1,
  ForwardingHistoryResponse_FieldNumber_LastOffsetIndex = 2,
};

@interface ForwardingHistoryResponse : GPBMessage

/**
 * / A list of forwarding events from the time slice of the time series
 * / specified in the request.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ForwardingEvent*> *forwardingEventsArray;
/** The number of items in @c forwardingEventsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger forwardingEventsArray_Count;

/**
 * / The index of the last time in the set of returned forwarding events. Can
 * / be used to seek further, pagination style.
 **/
@property(nonatomic, readwrite) uint32_t lastOffsetIndex;

@end

#pragma mark - ExportChannelBackupRequest

typedef GPB_ENUM(ExportChannelBackupRequest_FieldNumber) {
  ExportChannelBackupRequest_FieldNumber_ChanPoint = 1,
};

@interface ExportChannelBackupRequest : GPBMessage

/** / The target channel point to obtain a back up for. */
@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;
/** Test to see if @c chanPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChanPoint;

@end

#pragma mark - ChannelBackup

typedef GPB_ENUM(ChannelBackup_FieldNumber) {
  ChannelBackup_FieldNumber_ChanPoint = 1,
  ChannelBackup_FieldNumber_ChanBackup = 2,
};

@interface ChannelBackup : GPBMessage

/**
 * *
 * Identifies the channel that this backup belongs to.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChannelPoint *chanPoint;
/** Test to see if @c chanPoint has been set. */
@property(nonatomic, readwrite) BOOL hasChanPoint;

/**
 * *
 * Is an encrypted single-chan backup. this can be passed to
 * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
 * order to trigger the recovery protocol. When using REST, this field must be
 * encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *chanBackup;

@end

#pragma mark - MultiChanBackup

typedef GPB_ENUM(MultiChanBackup_FieldNumber) {
  MultiChanBackup_FieldNumber_ChanPointsArray = 1,
  MultiChanBackup_FieldNumber_MultiChanBackup = 2,
};

@interface MultiChanBackup : GPBMessage

/**
 * *
 * Is the set of all channels that are included in this multi-channel backup.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelPoint*> *chanPointsArray;
/** The number of items in @c chanPointsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger chanPointsArray_Count;

/**
 * *
 * A single encrypted blob containing all the static channel backups of the
 * channel listed above. This can be stored as a single file or blob, and
 * safely be replaced with any prior/future versions. When using REST, this
 * field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *multiChanBackup;

@end

#pragma mark - ChanBackupExportRequest

@interface ChanBackupExportRequest : GPBMessage

@end

#pragma mark - ChanBackupSnapshot

typedef GPB_ENUM(ChanBackupSnapshot_FieldNumber) {
  ChanBackupSnapshot_FieldNumber_SingleChanBackups = 1,
  ChanBackupSnapshot_FieldNumber_MultiChanBackup = 2,
};

@interface ChanBackupSnapshot : GPBMessage

/**
 * *
 * The set of new channels that have been added since the last channel backup
 * snapshot was requested.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChannelBackups *singleChanBackups;
/** Test to see if @c singleChanBackups has been set. */
@property(nonatomic, readwrite) BOOL hasSingleChanBackups;

/**
 * *
 * A multi-channel backup that covers all open channels currently known to
 * lnd.
 **/
@property(nonatomic, readwrite, strong, null_resettable) MultiChanBackup *multiChanBackup;
/** Test to see if @c multiChanBackup has been set. */
@property(nonatomic, readwrite) BOOL hasMultiChanBackup;

@end

#pragma mark - ChannelBackups

typedef GPB_ENUM(ChannelBackups_FieldNumber) {
  ChannelBackups_FieldNumber_ChanBackupsArray = 1,
};

@interface ChannelBackups : GPBMessage

/**
 * *
 * A set of single-chan static channel backups.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ChannelBackup*> *chanBackupsArray;
/** The number of items in @c chanBackupsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger chanBackupsArray_Count;

@end

#pragma mark - RestoreChanBackupRequest

typedef GPB_ENUM(RestoreChanBackupRequest_FieldNumber) {
  RestoreChanBackupRequest_FieldNumber_ChanBackups = 1,
  RestoreChanBackupRequest_FieldNumber_MultiChanBackup = 2,
};

typedef GPB_ENUM(RestoreChanBackupRequest_Backup_OneOfCase) {
  RestoreChanBackupRequest_Backup_OneOfCase_GPBUnsetOneOfCase = 0,
  RestoreChanBackupRequest_Backup_OneOfCase_ChanBackups = 1,
  RestoreChanBackupRequest_Backup_OneOfCase_MultiChanBackup = 2,
};

@interface RestoreChanBackupRequest : GPBMessage

@property(nonatomic, readonly) RestoreChanBackupRequest_Backup_OneOfCase backupOneOfCase;

/**
 * *
 * The channels to restore as a list of channel/backup pairs.
 **/
@property(nonatomic, readwrite, strong, null_resettable) ChannelBackups *chanBackups;

/**
 * *
 * The channels to restore in the packed multi backup format. When using
 * REST, this field must be encoded as base64.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *multiChanBackup;

@end

/**
 * Clears whatever value was set for the oneof 'backup'.
 **/
void RestoreChanBackupRequest_ClearBackupOneOfCase(RestoreChanBackupRequest *message);

#pragma mark - RestoreBackupResponse

@interface RestoreBackupResponse : GPBMessage

@end

#pragma mark - ChannelBackupSubscription

@interface ChannelBackupSubscription : GPBMessage

@end

#pragma mark - VerifyChanBackupResponse

@interface VerifyChanBackupResponse : GPBMessage

@end

#pragma mark - MacaroonPermission

typedef GPB_ENUM(MacaroonPermission_FieldNumber) {
  MacaroonPermission_FieldNumber_Entity = 1,
  MacaroonPermission_FieldNumber_Action = 2,
};

@interface MacaroonPermission : GPBMessage

/** / The entity a permission grants access to. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *entity;

/** / The action that is granted. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *action;

@end

#pragma mark - BakeMacaroonRequest

typedef GPB_ENUM(BakeMacaroonRequest_FieldNumber) {
  BakeMacaroonRequest_FieldNumber_PermissionsArray = 1,
};

@interface BakeMacaroonRequest : GPBMessage

/** / The list of permissions the new macaroon should grant. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<MacaroonPermission*> *permissionsArray;
/** The number of items in @c permissionsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger permissionsArray_Count;

@end

#pragma mark - BakeMacaroonResponse

typedef GPB_ENUM(BakeMacaroonResponse_FieldNumber) {
  BakeMacaroonResponse_FieldNumber_Macaroon = 1,
};

@interface BakeMacaroonResponse : GPBMessage

/** / The hex encoded macaroon, serialized in binary format. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *macaroon;

@end

#pragma mark - Failure

typedef GPB_ENUM(Failure_FieldNumber) {
  Failure_FieldNumber_Code = 1,
  Failure_FieldNumber_ChannelUpdate = 3,
  Failure_FieldNumber_HtlcMsat = 4,
  Failure_FieldNumber_OnionSha256 = 5,
  Failure_FieldNumber_CltvExpiry = 6,
  Failure_FieldNumber_Flags = 7,
  Failure_FieldNumber_FailureSourceIndex = 8,
  Failure_FieldNumber_Height = 9,
};

@interface Failure : GPBMessage

/** / Failure code as defined in the Lightning spec */
@property(nonatomic, readwrite) Failure_FailureCode code;

/** / An optional channel update message. */
@property(nonatomic, readwrite, strong, null_resettable) ChannelUpdate *channelUpdate;
/** Test to see if @c channelUpdate has been set. */
@property(nonatomic, readwrite) BOOL hasChannelUpdate;

/** / A failure type-dependent htlc value. */
@property(nonatomic, readwrite) uint64_t htlcMsat;

/** / The sha256 sum of the onion payload. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *onionSha256;

/** / A failure type-dependent cltv expiry value. */
@property(nonatomic, readwrite) uint32_t cltvExpiry;

/** / A failure type-dependent flags value. */
@property(nonatomic, readwrite) uint32_t flags;

/**
 * *
 * The position in the path of the intermediate or final node that generated
 * the failure message. Position zero is the sender node.
 **/
@property(nonatomic, readwrite) uint32_t failureSourceIndex;

/** / A failure type-dependent block height. */
@property(nonatomic, readwrite) uint32_t height;

@end

/**
 * Fetches the raw value of a @c Failure's @c code property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Failure_Code_RawValue(Failure *message);
/**
 * Sets the raw value of an @c Failure's @c code property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetFailure_Code_RawValue(Failure *message, int32_t value);

#pragma mark - ChannelUpdate

typedef GPB_ENUM(ChannelUpdate_FieldNumber) {
  ChannelUpdate_FieldNumber_Signature = 1,
  ChannelUpdate_FieldNumber_ChainHash = 2,
  ChannelUpdate_FieldNumber_ChanId = 3,
  ChannelUpdate_FieldNumber_Timestamp = 4,
  ChannelUpdate_FieldNumber_ChannelFlags = 5,
  ChannelUpdate_FieldNumber_TimeLockDelta = 6,
  ChannelUpdate_FieldNumber_HtlcMinimumMsat = 7,
  ChannelUpdate_FieldNumber_BaseFee = 8,
  ChannelUpdate_FieldNumber_FeeRate = 9,
  ChannelUpdate_FieldNumber_MessageFlags = 10,
  ChannelUpdate_FieldNumber_HtlcMaximumMsat = 11,
  ChannelUpdate_FieldNumber_ExtraOpaqueData = 12,
};

@interface ChannelUpdate : GPBMessage

/**
 * *
 * The signature that validates the announced data and proves the ownership
 * of node id.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *signature;

/**
 * *
 * The target chain that this channel was opened within. This value
 * should be the genesis hash of the target chain. Along with the short
 * channel ID, this uniquely identifies the channel globally in a
 * blockchain.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *chainHash;

/**
 * *
 * The unique description of the funding transaction.
 **/
@property(nonatomic, readwrite) uint64_t chanId;

/**
 * *
 * A timestamp that allows ordering in the case of multiple announcements.
 * We should ignore the message if timestamp is not greater than the
 * last-received.
 **/
@property(nonatomic, readwrite) uint32_t timestamp;

/**
 * *
 * The bitfield that describes whether optional fields are present in this
 * update. Currently, the least-significant bit must be set to 1 if the
 * optional field MaxHtlc is present.
 **/
@property(nonatomic, readwrite) uint32_t messageFlags;

/**
 * *
 * The bitfield that describes additional meta-data concerning how the
 * update is to be interpreted. Currently, the least-significant bit must be
 * set to 0 if the creating node corresponds to the first node in the
 * previously sent channel announcement and 1 otherwise. If the second bit
 * is set, then the channel is set to be disabled.
 **/
@property(nonatomic, readwrite) uint32_t channelFlags;

/**
 * *
 * The minimum number of blocks this node requires to be added to the expiry
 * of HTLCs. This is a security parameter determined by the node operator.
 * This value represents the required gap between the time locks of the
 * incoming and outgoing HTLC's set to this node.
 **/
@property(nonatomic, readwrite) uint32_t timeLockDelta;

/**
 * *
 * The minimum HTLC value which will be accepted.
 **/
@property(nonatomic, readwrite) uint64_t htlcMinimumMsat;

/**
 * *
 * The base fee that must be used for incoming HTLC's to this particular
 * channel. This value will be tacked onto the required for a payment
 * independent of the size of the payment.
 **/
@property(nonatomic, readwrite) uint32_t baseFee;

/**
 * *
 * The fee rate that will be charged per millionth of a satoshi.
 **/
@property(nonatomic, readwrite) uint32_t feeRate;

/**
 * *
 * The maximum HTLC value which will be accepted.
 **/
@property(nonatomic, readwrite) uint64_t htlcMaximumMsat;

/**
 * *
 * The set of data that was appended to this message, some of which we may
 * not actually know how to iterate or parse. By holding onto this data, we
 * ensure that we're able to properly validate the set of signatures that
 * cover these new fields, and ensure we're able to make upgrades to the
 * network in a forwards compatible manner.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *extraOpaqueData;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
