// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Rpc.pbobjc.h"
//#import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - RpcRoot

@implementation RpcRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
//    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - RpcRoot_FileDescriptor

static GPBFileDescriptor *RpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"lnrpc"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum AddressType

GPBEnumDescriptor *AddressType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WitnessPubkeyHash\000NestedPubkeyHash\000Unuse"
        "dWitnessPubkeyHash\000UnusedNestedPubkeyHas"
        "h\000";
    static const int32_t values[] = {
        AddressType_WitnessPubkeyHash,
        AddressType_NestedPubkeyHash,
        AddressType_UnusedWitnessPubkeyHash,
        AddressType_UnusedNestedPubkeyHash,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AddressType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AddressType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AddressType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AddressType_WitnessPubkeyHash:
    case AddressType_NestedPubkeyHash:
    case AddressType_UnusedWitnessPubkeyHash:
    case AddressType_UnusedNestedPubkeyHash:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GenSeedRequest

@implementation GenSeedRequest

@dynamic aezeedPassphrase;
@dynamic seedEntropy;

typedef struct GenSeedRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *aezeedPassphrase;
  NSData *seedEntropy;
} GenSeedRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenSeedRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "seedEntropy",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedRequest_FieldNumber_SeedEntropy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenSeedRequest__storage_, seedEntropy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenSeedRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenSeedRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenSeedResponse

@implementation GenSeedResponse

@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic encipheredSeed;

typedef struct GenSeedResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *encipheredSeed;
} GenSeedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedResponse_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GenSeedResponse__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encipheredSeed",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedResponse_FieldNumber_EncipheredSeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenSeedResponse__storage_, encipheredSeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenSeedResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenSeedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitWalletRequest

@implementation InitWalletRequest

@dynamic walletPassword;
@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic aezeedPassphrase;
@dynamic recoveryWindow;
@dynamic hasChannelBackups, channelBackups;

typedef struct InitWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t recoveryWindow;
  NSData *walletPassword;
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *aezeedPassphrase;
  ChanBackupSnapshot *channelBackups;
} InitWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "recoveryWindow",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_RecoveryWindow,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, recoveryWindow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channelBackups",
        .dataTypeSpecific.className = GPBStringifySymbol(ChanBackupSnapshot),
        .number = InitWalletRequest_FieldNumber_ChannelBackups,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, channelBackups),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InitWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitWalletResponse

@implementation InitWalletResponse


typedef struct InitWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} InitWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(InitWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnlockWalletRequest

@implementation UnlockWalletRequest

@dynamic walletPassword;
@dynamic recoveryWindow;
@dynamic hasChannelBackups, channelBackups;

typedef struct UnlockWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t recoveryWindow;
  NSData *walletPassword;
  ChanBackupSnapshot *channelBackups;
} UnlockWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = UnlockWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnlockWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "recoveryWindow",
        .dataTypeSpecific.className = NULL,
        .number = UnlockWalletRequest_FieldNumber_RecoveryWindow,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnlockWalletRequest__storage_, recoveryWindow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channelBackups",
        .dataTypeSpecific.className = GPBStringifySymbol(ChanBackupSnapshot),
        .number = UnlockWalletRequest_FieldNumber_ChannelBackups,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnlockWalletRequest__storage_, channelBackups),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnlockWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnlockWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnlockWalletResponse

@implementation UnlockWalletResponse


typedef struct UnlockWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} UnlockWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnlockWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(UnlockWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangePasswordRequest

@implementation ChangePasswordRequest

@dynamic currentPassword;
@dynamic newPassword;

typedef struct ChangePasswordRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *currentPassword;
  NSData *newPassword;
} ChangePasswordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentPassword",
        .dataTypeSpecific.className = NULL,
        .number = ChangePasswordRequest_FieldNumber_CurrentPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangePasswordRequest__storage_, currentPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = ChangePasswordRequest_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangePasswordRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangePasswordRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangePasswordRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangePasswordResponse

@implementation ChangePasswordResponse


typedef struct ChangePasswordResponse__storage_ {
  uint32_t _has_storage_[1];
} ChangePasswordResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangePasswordResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChangePasswordResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Utxo

@implementation Utxo

@dynamic type;
@dynamic address;
@dynamic amountSat;
@dynamic pkScript;
@dynamic hasOutpoint, outpoint;
@dynamic confirmations;

typedef struct Utxo__storage_ {
  uint32_t _has_storage_[1];
  AddressType type;
  NSString *address;
  NSString *pkScript;
  OutPoint *outpoint;
  int64_t amountSat;
  int64_t confirmations;
} Utxo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AddressType_EnumDescriptor,
        .number = Utxo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Utxo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Utxo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amountSat",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_AmountSat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Utxo__storage_, amountSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pkScript",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_PkScript,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Utxo__storage_, pkScript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.className = GPBStringifySymbol(OutPoint),
        .number = Utxo_FieldNumber_Outpoint,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Utxo__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.className = NULL,
        .number = Utxo_FieldNumber_Confirmations,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Utxo__storage_, confirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Utxo class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Utxo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Utxo_Type_RawValue(Utxo *message) {
  GPBDescriptor *descriptor = [Utxo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Utxo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetUtxo_Type_RawValue(Utxo *message, int32_t value) {
  GPBDescriptor *descriptor = [Utxo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Utxo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Transaction

@implementation Transaction

@dynamic txHash;
@dynamic amount;
@dynamic numConfirmations;
@dynamic blockHash;
@dynamic blockHeight;
@dynamic timeStamp;
@dynamic totalFees;
@dynamic destAddressesArray, destAddressesArray_Count;
@dynamic rawTxHex;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t numConfirmations;
  int32_t blockHeight;
  NSString *txHash;
  NSString *blockHash;
  NSMutableArray *destAddressesArray;
  NSString *rawTxHex;
  int64_t amount;
  int64_t timeStamp;
  int64_t totalFees;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numConfirmations",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_NumConfirmations,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, numConfirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BlockHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BlockHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TimeStamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TotalFees,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "destAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_DestAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, destAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawTxHex",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_RawTxHex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, rawTxHex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionsRequest

@implementation GetTransactionsRequest


typedef struct GetTransactionsRequest__storage_ {
  uint32_t _has_storage_[1];
} GetTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetTransactionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionDetails

@implementation TransactionDetails

@dynamic transactionsArray, transactionsArray_Count;

typedef struct TransactionDetails__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} TransactionDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionDetails_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionDetails__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionDetails class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeLimit

@implementation FeeLimit

@dynamic limitOneOfCase;
@dynamic fixed;
@dynamic percent;

typedef struct FeeLimit__storage_ {
  uint32_t _has_storage_[2];
  int64_t fixed;
  int64_t percent;
} FeeLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fixed",
        .dataTypeSpecific.className = NULL,
        .number = FeeLimit_FieldNumber_Fixed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(FeeLimit__storage_, fixed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "percent",
        .dataTypeSpecific.className = NULL,
        .number = FeeLimit_FieldNumber_Percent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(FeeLimit__storage_, percent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeLimit class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeeLimit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "limit",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void FeeLimit_ClearLimitOneOfCase(FeeLimit *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - SendRequest

@implementation SendRequest

@dynamic dest;
@dynamic destString;
@dynamic amt;
@dynamic paymentHash;
@dynamic paymentHashString;
@dynamic paymentRequest;
@dynamic finalCltvDelta;
@dynamic hasFeeLimit, feeLimit;
@dynamic outgoingChanId;
@dynamic cltvLimit;

typedef struct SendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t finalCltvDelta;
  uint32_t cltvLimit;
  NSData *dest;
  NSString *destString;
  NSData *paymentHash;
  NSString *paymentHashString;
  NSString *paymentRequest;
  FeeLimit *feeLimit;
  int64_t amt;
  uint64_t outgoingChanId;
} SendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dest",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_Dest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendRequest__storage_, dest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "destString",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_DestString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendRequest__storage_, destString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_Amt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentHashString",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentHashString,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentHashString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentRequest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "finalCltvDelta",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_FinalCltvDelta,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendRequest__storage_, finalCltvDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = GPBStringifySymbol(FeeLimit),
        .number = SendRequest_FieldNumber_FeeLimit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendRequest__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outgoingChanId",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_OutgoingChanId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendRequest__storage_, outgoingChanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "cltvLimit",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_CltvLimit,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendRequest__storage_, cltvLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendResponse

@implementation SendResponse

@dynamic paymentError;
@dynamic paymentPreimage;
@dynamic hasPaymentRoute, paymentRoute;
@dynamic paymentHash;

typedef struct SendResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentError;
  NSData *paymentPreimage;
  Route *paymentRoute;
  NSData *paymentHash;
} SendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentError",
        .dataTypeSpecific.className = NULL,
        .number = SendResponse_FieldNumber_PaymentError,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentError),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = SendResponse_FieldNumber_PaymentPreimage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRoute",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = SendResponse_FieldNumber_PaymentRoute,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentRoute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = SendResponse_FieldNumber_PaymentHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendToRouteRequest

@implementation SendToRouteRequest

@dynamic paymentHash;
@dynamic paymentHashString;
@dynamic hasRoute, route;

typedef struct SendToRouteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *paymentHash;
  NSString *paymentHashString;
  Route *route;
} SendToRouteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = SendToRouteRequest_FieldNumber_PaymentHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendToRouteRequest__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentHashString",
        .dataTypeSpecific.className = NULL,
        .number = SendToRouteRequest_FieldNumber_PaymentHashString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendToRouteRequest__storage_, paymentHashString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = SendToRouteRequest_FieldNumber_Route,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendToRouteRequest__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToRouteRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToRouteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelPoint

@implementation ChannelPoint

@dynamic fundingTxidOneOfCase;
@dynamic fundingTxidBytes;
@dynamic fundingTxidStr;
@dynamic outputIndex;

typedef struct ChannelPoint__storage_ {
  uint32_t _has_storage_[2];
  uint32_t outputIndex;
  NSData *fundingTxidBytes;
  NSString *fundingTxidStr;
} ChannelPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fundingTxidBytes",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_FundingTxidBytes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, fundingTxidBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fundingTxidStr",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_FundingTxidStr,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, fundingTxidStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_OutputIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelPoint class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "fundingTxid",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ChannelPoint_ClearFundingTxidOneOfCase(ChannelPoint *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - OutPoint

@implementation OutPoint

@dynamic txidBytes;
@dynamic txidStr;
@dynamic outputIndex;

typedef struct OutPoint__storage_ {
  uint32_t _has_storage_[1];
  uint32_t outputIndex;
  NSData *txidBytes;
  NSString *txidStr;
} OutPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txidBytes",
        .dataTypeSpecific.className = NULL,
        .number = OutPoint_FieldNumber_TxidBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OutPoint__storage_, txidBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txidStr",
        .dataTypeSpecific.className = NULL,
        .number = OutPoint_FieldNumber_TxidStr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OutPoint__storage_, txidStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = OutPoint_FieldNumber_OutputIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OutPoint__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutPoint class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LightningAddress

@implementation LightningAddress

@dynamic pubkey;
@dynamic host;

typedef struct LightningAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
  NSString *host;
} LightningAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = LightningAddress_FieldNumber_Pubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LightningAddress__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = LightningAddress_FieldNumber_Host,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LightningAddress__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LightningAddress class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LightningAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EstimateFeeRequest

@implementation EstimateFeeRequest

@dynamic addrToAmount, addrToAmount_Count;
@dynamic targetConf;

typedef struct EstimateFeeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  GPBStringInt64Dictionary *addrToAmount;
} EstimateFeeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrToAmount",
        .dataTypeSpecific.className = NULL,
        .number = EstimateFeeRequest_FieldNumber_AddrToAmount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EstimateFeeRequest__storage_, addrToAmount),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = EstimateFeeRequest_FieldNumber_TargetConf,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EstimateFeeRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EstimateFeeRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EstimateFeeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EstimateFeeResponse

@implementation EstimateFeeResponse

@dynamic feeSat;
@dynamic feerateSatPerByte;

typedef struct EstimateFeeResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t feeSat;
  int64_t feerateSatPerByte;
} EstimateFeeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "feeSat",
        .dataTypeSpecific.className = NULL,
        .number = EstimateFeeResponse_FieldNumber_FeeSat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EstimateFeeResponse__storage_, feeSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feerateSatPerByte",
        .dataTypeSpecific.className = NULL,
        .number = EstimateFeeResponse_FieldNumber_FeerateSatPerByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EstimateFeeResponse__storage_, feerateSatPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EstimateFeeResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EstimateFeeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyRequest

@implementation SendManyRequest

@dynamic addrToAmount, addrToAmount_Count;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct SendManyRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  GPBStringInt64Dictionary *addrToAmount;
  int64_t satPerByte;
} SendManyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrToAmount",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_AddrToAmount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, addrToAmount),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_TargetConf,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_SatPerByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyResponse

@implementation SendManyResponse

@dynamic txid;

typedef struct SendManyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} SendManyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SendManyResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendManyResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendCoinsRequest

@implementation SendCoinsRequest

@dynamic addr;
@dynamic amount;
@dynamic targetConf;
@dynamic satPerByte;
@dynamic sendAll;

typedef struct SendCoinsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  NSString *addr;
  int64_t amount;
  int64_t satPerByte;
} SendCoinsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_TargetConf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_SatPerByte,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sendAll",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_SendAll,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendCoinsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendCoinsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendCoinsResponse

@implementation SendCoinsResponse

@dynamic txid;

typedef struct SendCoinsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} SendCoinsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendCoinsResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendCoinsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendCoinsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListUnspentRequest

@implementation ListUnspentRequest

@dynamic minConfs;
@dynamic maxConfs;

typedef struct ListUnspentRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t minConfs;
  int32_t maxConfs;
} ListUnspentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minConfs",
        .dataTypeSpecific.className = NULL,
        .number = ListUnspentRequest_FieldNumber_MinConfs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListUnspentRequest__storage_, minConfs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxConfs",
        .dataTypeSpecific.className = NULL,
        .number = ListUnspentRequest_FieldNumber_MaxConfs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ListUnspentRequest__storage_, maxConfs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListUnspentRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListUnspentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListUnspentResponse

@implementation ListUnspentResponse

@dynamic utxosArray, utxosArray_Count;

typedef struct ListUnspentResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *utxosArray;
} ListUnspentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "utxosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Utxo),
        .number = ListUnspentResponse_FieldNumber_UtxosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListUnspentResponse__storage_, utxosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListUnspentResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListUnspentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAddressRequest

@implementation NewAddressRequest

@dynamic type;

typedef struct NewAddressRequest__storage_ {
  uint32_t _has_storage_[1];
  AddressType type;
} NewAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AddressType_EnumDescriptor,
        .number = NewAddressRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAddressRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NewAddressRequest_Type_RawValue(NewAddressRequest *message) {
  GPBDescriptor *descriptor = [NewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NewAddressRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetNewAddressRequest_Type_RawValue(NewAddressRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [NewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NewAddressRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - NewAddressResponse

@implementation NewAddressResponse

@dynamic address;

typedef struct NewAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} NewAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = NewAddressResponse_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAddressResponse__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageRequest

@implementation SignMessageRequest

@dynamic msg;

typedef struct SignMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
} SignMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageResponse

@implementation SignMessageResponse

@dynamic signature;

typedef struct SignMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *signature;
} SignMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageResponse_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageResponse__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageRequest

@implementation VerifyMessageRequest

@dynamic msg;
@dynamic signature;

typedef struct VerifyMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
  NSString *signature;
} VerifyMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageResponse

@implementation VerifyMessageResponse

@dynamic valid;
@dynamic pubkey;

typedef struct VerifyMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
} VerifyMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valid",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageResponse_FieldNumber_Valid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageResponse_FieldNumber_Pubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyMessageResponse__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectPeerRequest

@implementation ConnectPeerRequest

@dynamic hasAddr, addr;
@dynamic perm;

typedef struct ConnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  LightningAddress *addr;
} ConnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningAddress),
        .number = ConnectPeerRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectPeerRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "perm",
        .dataTypeSpecific.className = NULL,
        .number = ConnectPeerRequest_FieldNumber_Perm,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectPeerRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectPeerResponse

@implementation ConnectPeerResponse


typedef struct ConnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} ConnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectPeerResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ConnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectPeerRequest

@implementation DisconnectPeerRequest

@dynamic pubKey;

typedef struct DisconnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} DisconnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = DisconnectPeerRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectPeerRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectPeerRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectPeerResponse

@implementation DisconnectPeerResponse


typedef struct DisconnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} DisconnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectPeerResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DisconnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HTLC

@implementation HTLC

@dynamic incoming;
@dynamic amount;
@dynamic hashLock;
@dynamic expirationHeight;

typedef struct HTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expirationHeight;
  NSData *hashLock;
  int64_t amount;
} HTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashLock",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_HashLock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HTLC__storage_, hashLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expirationHeight",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_ExpirationHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HTLC__storage_, expirationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HTLC class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Channel

@implementation Channel

@dynamic active;
@dynamic remotePubkey;
@dynamic channelPoint;
@dynamic chanId;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;
@dynamic unsettledBalance;
@dynamic totalSatoshisSent;
@dynamic totalSatoshisReceived;
@dynamic numUpdates;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;
@dynamic csvDelay;
@dynamic private_p;
@dynamic initiator;
@dynamic chanStatusFlags;

typedef struct Channel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t csvDelay;
  NSString *remotePubkey;
  NSString *channelPoint;
  NSMutableArray *pendingHtlcsArray;
  NSString *chanStatusFlags;
  uint64_t chanId;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
  int64_t unsettledBalance;
  int64_t totalSatoshisSent;
  int64_t totalSatoshisReceived;
  uint64_t numUpdates;
} Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "active",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Active,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remotePubkey",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_RemotePubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Channel__storage_, remotePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_ChannelPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Channel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_ChanId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Channel__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Channel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_LocalBalance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Channel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_RemoteBalance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Channel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_CommitFee,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Channel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_CommitWeight,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Channel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_FeePerKw,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Channel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unsettledBalance",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_UnsettledBalance,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Channel__storage_, unsettledBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisSent",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_TotalSatoshisSent,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Channel__storage_, totalSatoshisSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisReceived",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_TotalSatoshisReceived,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Channel__storage_, totalSatoshisReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numUpdates",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_NumUpdates,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Channel__storage_, numUpdates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(HTLC),
        .number = Channel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Channel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "csvDelay",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_CsvDelay,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Channel__storage_, csvDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Private_p,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Initiator,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chanStatusFlags",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_ChanStatusFlags,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Channel__storage_, chanStatusFlags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Channel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Channel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListChannelsRequest

@implementation ListChannelsRequest

@dynamic activeOnly;
@dynamic inactiveOnly;
@dynamic publicOnly;
@dynamic privateOnly;

typedef struct ListChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} ListChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activeOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListChannelsRequest_FieldNumber_ActiveOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inactiveOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListChannelsRequest_FieldNumber_InactiveOnly,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "publicOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListChannelsRequest_FieldNumber_PublicOnly,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "privateOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListChannelsRequest_FieldNumber_PrivateOnly,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListChannelsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListChannelsResponse

@implementation ListChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct ListChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} ListChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ListChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListChannelsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelCloseSummary

@implementation ChannelCloseSummary

@dynamic channelPoint;
@dynamic chanId;
@dynamic chainHash;
@dynamic closingTxHash;
@dynamic remotePubkey;
@dynamic capacity;
@dynamic closeHeight;
@dynamic settledBalance;
@dynamic timeLockedBalance;
@dynamic closeType;

typedef struct ChannelCloseSummary__storage_ {
  uint32_t _has_storage_[1];
  uint32_t closeHeight;
  ChannelCloseSummary_ClosureType closeType;
  NSString *channelPoint;
  NSString *chainHash;
  NSString *closingTxHash;
  NSString *remotePubkey;
  uint64_t chanId;
  int64_t capacity;
  int64_t settledBalance;
  int64_t timeLockedBalance;
} ChannelCloseSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_ChanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chainHash",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_ChainHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, chainHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "closingTxHash",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_ClosingTxHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, closingTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remotePubkey",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_RemotePubkey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, remotePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closeHeight",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_CloseHeight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, closeHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "settledBalance",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_SettledBalance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, settledBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeLockedBalance",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseSummary_FieldNumber_TimeLockedBalance,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, timeLockedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closeType",
        .dataTypeSpecific.enumDescFunc = ChannelCloseSummary_ClosureType_EnumDescriptor,
        .number = ChannelCloseSummary_FieldNumber_CloseType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ChannelCloseSummary__storage_, closeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelCloseSummary class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelCloseSummary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChannelCloseSummary_CloseType_RawValue(ChannelCloseSummary *message) {
  GPBDescriptor *descriptor = [ChannelCloseSummary descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelCloseSummary_FieldNumber_CloseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelCloseSummary_CloseType_RawValue(ChannelCloseSummary *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelCloseSummary descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelCloseSummary_FieldNumber_CloseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChannelCloseSummary_ClosureType

GPBEnumDescriptor *ChannelCloseSummary_ClosureType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CooperativeClose\000LocalForceClose\000RemoteF"
        "orceClose\000BreachClose\000FundingCanceled\000Ab"
        "andoned\000";
    static const int32_t values[] = {
        ChannelCloseSummary_ClosureType_CooperativeClose,
        ChannelCloseSummary_ClosureType_LocalForceClose,
        ChannelCloseSummary_ClosureType_RemoteForceClose,
        ChannelCloseSummary_ClosureType_BreachClose,
        ChannelCloseSummary_ClosureType_FundingCanceled,
        ChannelCloseSummary_ClosureType_Abandoned,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelCloseSummary_ClosureType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelCloseSummary_ClosureType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelCloseSummary_ClosureType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelCloseSummary_ClosureType_CooperativeClose:
    case ChannelCloseSummary_ClosureType_LocalForceClose:
    case ChannelCloseSummary_ClosureType_RemoteForceClose:
    case ChannelCloseSummary_ClosureType_BreachClose:
    case ChannelCloseSummary_ClosureType_FundingCanceled:
    case ChannelCloseSummary_ClosureType_Abandoned:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ClosedChannelsRequest

@implementation ClosedChannelsRequest

@dynamic cooperative;
@dynamic localForce;
@dynamic remoteForce;
@dynamic breach;
@dynamic fundingCanceled;
@dynamic abandoned;

typedef struct ClosedChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} ClosedChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cooperative",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_Cooperative,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "localForce",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_LocalForce,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remoteForce",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_RemoteForce,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "breach",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_Breach,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fundingCanceled",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_FundingCanceled,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "abandoned",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelsRequest_FieldNumber_Abandoned,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClosedChannelsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClosedChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClosedChannelsResponse

@implementation ClosedChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct ClosedChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} ClosedChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelCloseSummary),
        .number = ClosedChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClosedChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClosedChannelsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClosedChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peer

@implementation Peer

@dynamic pubKey;
@dynamic address;
@dynamic bytesSent;
@dynamic bytesRecv;
@dynamic satSent;
@dynamic satRecv;
@dynamic inbound;
@dynamic pingTime;
@dynamic syncType;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  Peer_SyncType syncType;
  NSString *pubKey;
  NSString *address;
  uint64_t bytesSent;
  uint64_t bytesRecv;
  int64_t satSent;
  int64_t satRecv;
  int64_t pingTime;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Peer__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bytesSent",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_BytesSent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Peer__storage_, bytesSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "bytesRecv",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_BytesRecv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Peer__storage_, bytesRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "satSent",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_SatSent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Peer__storage_, satSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "satRecv",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_SatRecv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Peer__storage_, satRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inbound",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Inbound,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pingTime",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_PingTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Peer__storage_, pingTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "syncType",
        .dataTypeSpecific.enumDescFunc = Peer_SyncType_EnumDescriptor,
        .number = Peer_FieldNumber_SyncType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Peer__storage_, syncType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Peer_SyncType_RawValue(Peer *message) {
  GPBDescriptor *descriptor = [Peer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Peer_FieldNumber_SyncType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPeer_SyncType_RawValue(Peer *message, int32_t value) {
  GPBDescriptor *descriptor = [Peer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Peer_FieldNumber_SyncType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Peer_SyncType

GPBEnumDescriptor *Peer_SyncType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownSync\000ActiveSync\000PassiveSync\000";
    static const int32_t values[] = {
        Peer_SyncType_UnknownSync,
        Peer_SyncType_ActiveSync,
        Peer_SyncType_PassiveSync,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Peer_SyncType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Peer_SyncType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Peer_SyncType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Peer_SyncType_UnknownSync:
    case Peer_SyncType_ActiveSync:
    case Peer_SyncType_PassiveSync:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ListPeersRequest

@implementation ListPeersRequest


typedef struct ListPeersRequest__storage_ {
  uint32_t _has_storage_[1];
} ListPeersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPeersRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListPeersRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPeersResponse

@implementation ListPeersResponse

@dynamic peersArray, peersArray_Count;

typedef struct ListPeersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} ListPeersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = ListPeersResponse_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListPeersResponse__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPeersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListPeersResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoRequest

@implementation GetInfoRequest


typedef struct GetInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} GetInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoResponse

@implementation GetInfoResponse

@dynamic identityPubkey;
@dynamic alias;
@dynamic numPendingChannels;
@dynamic numActiveChannels;
@dynamic numPeers;
@dynamic blockHeight;
@dynamic blockHash;
@dynamic syncedToChain;
@dynamic testnet;
@dynamic urisArray, urisArray_Count;
@dynamic bestHeaderTimestamp;
@dynamic version;
@dynamic numInactiveChannels;
@dynamic chainsArray, chainsArray_Count;
@dynamic color;

typedef struct GetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numPendingChannels;
  uint32_t numActiveChannels;
  uint32_t numPeers;
  uint32_t blockHeight;
  uint32_t numInactiveChannels;
  NSString *identityPubkey;
  NSString *alias;
  NSString *blockHash;
  NSMutableArray *urisArray;
  NSString *version;
  NSMutableArray *chainsArray;
  NSString *color;
  int64_t bestHeaderTimestamp;
} GetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityPubkey",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_IdentityPubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, identityPubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Alias,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numPendingChannels",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumPendingChannels,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numPendingChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numActiveChannels",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumActiveChannels,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numActiveChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numPeers",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumPeers,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BlockHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncedToChain",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_SyncedToChain,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "testnet",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Testnet,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "urisArray",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_UrisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, urisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bestHeaderTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BestHeaderTimestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, bestHeaderTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Version,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numInactiveChannels",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumInactiveChannels,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numInactiveChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Chain),
        .number = GetInfoResponse_FieldNumber_ChainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, chainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Color,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Chain

@implementation Chain

@dynamic chain;
@dynamic network;

typedef struct Chain__storage_ {
  uint32_t _has_storage_[1];
  NSString *chain;
  NSString *network;
} Chain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chain",
        .dataTypeSpecific.className = NULL,
        .number = Chain_FieldNumber_Chain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Chain__storage_, chain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "network",
        .dataTypeSpecific.className = NULL,
        .number = Chain_FieldNumber_Network,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Chain__storage_, network),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Chain class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Chain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfirmationUpdate

@implementation ConfirmationUpdate

@dynamic blockSha;
@dynamic blockHeight;
@dynamic numConfsLeft;

typedef struct ConfirmationUpdate__storage_ {
  uint32_t _has_storage_[1];
  int32_t blockHeight;
  uint32_t numConfsLeft;
  NSData *blockSha;
} ConfirmationUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockSha",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_BlockSha,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, blockSha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numConfsLeft",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_NumConfsLeft,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, numConfsLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfirmationUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfirmationUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelOpenUpdate

@implementation ChannelOpenUpdate

@dynamic hasChannelPoint, channelPoint;

typedef struct ChannelOpenUpdate__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *channelPoint;
} ChannelOpenUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelOpenUpdate_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelOpenUpdate__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelOpenUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelOpenUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelCloseUpdate

@implementation ChannelCloseUpdate

@dynamic closingTxid;
@dynamic success;

typedef struct ChannelCloseUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSData *closingTxid;
} ChannelCloseUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseUpdate_FieldNumber_ClosingTxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelCloseUpdate__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseUpdate_FieldNumber_Success,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelCloseUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelCloseUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseChannelRequest

@implementation CloseChannelRequest

@dynamic hasChannelPoint, channelPoint;
@dynamic force;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct CloseChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  ChannelPoint *channelPoint;
  int64_t satPerByte;
} CloseChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = CloseChannelRequest_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_Force,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseChannelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseStatusUpdate

@implementation CloseStatusUpdate

@dynamic updateOneOfCase;
@dynamic closePending;
@dynamic chanClose;

typedef struct CloseStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  PendingUpdate *closePending;
  ChannelCloseUpdate *chanClose;
} CloseStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closePending",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingUpdate),
        .number = CloseStatusUpdate_FieldNumber_ClosePending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CloseStatusUpdate__storage_, closePending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanClose",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelCloseUpdate),
        .number = CloseStatusUpdate_FieldNumber_ChanClose,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CloseStatusUpdate__storage_, chanClose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseStatusUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CloseStatusUpdate_ClearUpdateOneOfCase(CloseStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PendingUpdate

@implementation PendingUpdate

@dynamic txid;
@dynamic outputIndex;

typedef struct PendingUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t outputIndex;
  NSData *txid;
} PendingUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = PendingUpdate_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingUpdate__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = PendingUpdate_FieldNumber_OutputIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingUpdate__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenChannelRequest

@implementation OpenChannelRequest

@dynamic nodePubkey;
@dynamic nodePubkeyString;
@dynamic localFundingAmount;
@dynamic pushSat;
@dynamic targetConf;
@dynamic satPerByte;
@dynamic private_p;
@dynamic minHtlcMsat;
@dynamic remoteCsvDelay;
@dynamic minConfs;
@dynamic spendUnconfirmed;

typedef struct OpenChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  uint32_t remoteCsvDelay;
  int32_t minConfs;
  NSData *nodePubkey;
  NSString *nodePubkeyString;
  int64_t localFundingAmount;
  int64_t pushSat;
  int64_t satPerByte;
  int64_t minHtlcMsat;
} OpenChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodePubkey",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_NodePubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, nodePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nodePubkeyString",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_NodePubkeyString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, nodePubkeyString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "localFundingAmount",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_LocalFundingAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, localFundingAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pushSat",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_PushSat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, pushSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_Private_p,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minHtlcMsat",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_MinHtlcMsat,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, minHtlcMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteCsvDelay",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_RemoteCsvDelay,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, remoteCsvDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minConfs",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_MinConfs,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, minConfs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "spendUnconfirmed",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_SpendUnconfirmed,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenChannelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenStatusUpdate

@implementation OpenStatusUpdate

@dynamic updateOneOfCase;
@dynamic chanPending;
@dynamic chanOpen;

typedef struct OpenStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  PendingUpdate *chanPending;
  ChannelOpenUpdate *chanOpen;
} OpenStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPending",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingUpdate),
        .number = OpenStatusUpdate_FieldNumber_ChanPending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OpenStatusUpdate__storage_, chanPending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanOpen",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelOpenUpdate),
        .number = OpenStatusUpdate_FieldNumber_ChanOpen,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OpenStatusUpdate__storage_, chanOpen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenStatusUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void OpenStatusUpdate_ClearUpdateOneOfCase(OpenStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PendingHTLC

@implementation PendingHTLC

@dynamic incoming;
@dynamic amount;
@dynamic outpoint;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic stage;

typedef struct PendingHTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  uint32_t stage;
  NSString *outpoint;
  int64_t amount;
} PendingHTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Outpoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_MaturityHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_BlocksTilMaturity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stage",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Stage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, stage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingHTLC class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingHTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsRequest

@implementation PendingChannelsRequest


typedef struct PendingChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} PendingChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PendingChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse

@implementation PendingChannelsResponse

@dynamic totalLimboBalance;
@dynamic pendingOpenChannelsArray, pendingOpenChannelsArray_Count;
@dynamic pendingClosingChannelsArray, pendingClosingChannelsArray_Count;
@dynamic pendingForceClosingChannelsArray, pendingForceClosingChannelsArray_Count;
@dynamic waitingCloseChannelsArray, waitingCloseChannelsArray_Count;

typedef struct PendingChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pendingOpenChannelsArray;
  NSMutableArray *pendingClosingChannelsArray;
  NSMutableArray *pendingForceClosingChannelsArray;
  NSMutableArray *waitingCloseChannelsArray;
  int64_t totalLimboBalance;
} PendingChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalLimboBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_FieldNumber_TotalLimboBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, totalLimboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingOpenChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingOpenChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingOpenChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingOpenChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_ClosedChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingForceClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_ForceClosedChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingForceClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingForceClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "waitingCloseChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_WaitingCloseChannel),
        .number = PendingChannelsResponse_FieldNumber_WaitingCloseChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, waitingCloseChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_PendingChannel

@implementation PendingChannelsResponse_PendingChannel

@dynamic remoteNodePub;
@dynamic channelPoint;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;

typedef struct PendingChannelsResponse_PendingChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *remoteNodePub;
  NSString *channelPoint;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
} PendingChannelsResponse_PendingChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remoteNodePub",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_RemoteNodePub,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, remoteNodePub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_ChannelPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_LocalBalance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_RemoteBalance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_PendingChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_PendingChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_PendingOpenChannel

@implementation PendingChannelsResponse_PendingOpenChannel

@dynamic hasChannel, channel;
@dynamic confirmationHeight;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;

typedef struct PendingChannelsResponse_PendingOpenChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t confirmationHeight;
  PendingChannelsResponse_PendingChannel *channel;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
} PendingChannelsResponse_PendingOpenChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmationHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_ConfirmationHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, confirmationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitWeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_FeePerKw,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_PendingOpenChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_PendingOpenChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_WaitingCloseChannel

@implementation PendingChannelsResponse_WaitingCloseChannel

@dynamic hasChannel, channel;
@dynamic limboBalance;

typedef struct PendingChannelsResponse_WaitingCloseChannel__storage_ {
  uint32_t _has_storage_[1];
  PendingChannelsResponse_PendingChannel *channel;
  int64_t limboBalance;
} PendingChannelsResponse_WaitingCloseChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_WaitingCloseChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_WaitingCloseChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limboBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_WaitingCloseChannel_FieldNumber_LimboBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_WaitingCloseChannel__storage_, limboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_WaitingCloseChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_WaitingCloseChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_ClosedChannel

@implementation PendingChannelsResponse_ClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;

typedef struct PendingChannelsResponse_ClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  PendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
} PendingChannelsResponse_ClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_ClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_ClosedChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_ClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_ForceClosedChannel

@implementation PendingChannelsResponse_ForceClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;
@dynamic limboBalance;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic recoveredBalance;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;

typedef struct PendingChannelsResponse_ForceClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  PendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
  NSMutableArray *pendingHtlcsArray;
  int64_t limboBalance;
  int64_t recoveredBalance;
} PendingChannelsResponse_ForceClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limboBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_LimboBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, limboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_MaturityHeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_BlocksTilMaturity,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recoveredBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_RecoveredBalance,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, recoveredBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingHTLC),
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_ForceClosedChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_ForceClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEventSubscription

@implementation ChannelEventSubscription


typedef struct ChannelEventSubscription__storage_ {
  uint32_t _has_storage_[1];
} ChannelEventSubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEventSubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChannelEventSubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEventUpdate

@implementation ChannelEventUpdate

@dynamic channelOneOfCase;
@dynamic openChannel;
@dynamic closedChannel;
@dynamic activeChannel;
@dynamic inactiveChannel;
@dynamic type;

typedef struct ChannelEventUpdate__storage_ {
  uint32_t _has_storage_[2];
  ChannelEventUpdate_UpdateType type;
  Channel *openChannel;
  ChannelCloseSummary *closedChannel;
  ChannelPoint *activeChannel;
  ChannelPoint *inactiveChannel;
} ChannelEventUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "openChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ChannelEventUpdate_FieldNumber_OpenChannel,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelEventUpdate__storage_, openChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closedChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelCloseSummary),
        .number = ChannelEventUpdate_FieldNumber_ClosedChannel,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelEventUpdate__storage_, closedChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelEventUpdate_FieldNumber_ActiveChannel,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelEventUpdate__storage_, activeChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inactiveChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelEventUpdate_FieldNumber_InactiveChannel,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelEventUpdate__storage_, inactiveChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChannelEventUpdate_UpdateType_EnumDescriptor,
        .number = ChannelEventUpdate_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelEventUpdate__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEventUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelEventUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "channel",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChannelEventUpdate_Type_RawValue(ChannelEventUpdate *message) {
  GPBDescriptor *descriptor = [ChannelEventUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelEventUpdate_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelEventUpdate_Type_RawValue(ChannelEventUpdate *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelEventUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelEventUpdate_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void ChannelEventUpdate_ClearChannelOneOfCase(ChannelEventUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum ChannelEventUpdate_UpdateType

GPBEnumDescriptor *ChannelEventUpdate_UpdateType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "OpenChannel\000ClosedChannel\000ActiveChannel\000"
        "InactiveChannel\000";
    static const int32_t values[] = {
        ChannelEventUpdate_UpdateType_OpenChannel,
        ChannelEventUpdate_UpdateType_ClosedChannel,
        ChannelEventUpdate_UpdateType_ActiveChannel,
        ChannelEventUpdate_UpdateType_InactiveChannel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelEventUpdate_UpdateType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelEventUpdate_UpdateType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelEventUpdate_UpdateType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelEventUpdate_UpdateType_OpenChannel:
    case ChannelEventUpdate_UpdateType_ClosedChannel:
    case ChannelEventUpdate_UpdateType_ActiveChannel:
    case ChannelEventUpdate_UpdateType_InactiveChannel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - WalletBalanceRequest

@implementation WalletBalanceRequest


typedef struct WalletBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} WalletBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WalletBalanceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(WalletBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WalletBalanceResponse

@implementation WalletBalanceResponse

@dynamic totalBalance;
@dynamic confirmedBalance;
@dynamic unconfirmedBalance;

typedef struct WalletBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalBalance;
  int64_t confirmedBalance;
  int64_t unconfirmedBalance;
} WalletBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_TotalBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, totalBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "confirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_ConfirmedBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, confirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unconfirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_UnconfirmedBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, unconfirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WalletBalanceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WalletBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBalanceRequest

@implementation ChannelBalanceRequest


typedef struct ChannelBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} ChannelBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBalanceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChannelBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBalanceResponse

@implementation ChannelBalanceResponse

@dynamic balance;
@dynamic pendingOpenBalance;

typedef struct ChannelBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t balance;
  int64_t pendingOpenBalance;
} ChannelBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBalanceResponse_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelBalanceResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingOpenBalance",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBalanceResponse_FieldNumber_PendingOpenBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelBalanceResponse__storage_, pendingOpenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBalanceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryRoutesRequest

@implementation QueryRoutesRequest

@dynamic pubKey;
@dynamic amt;
@dynamic finalCltvDelta;
@dynamic hasFeeLimit, feeLimit;
@dynamic ignoredNodesArray, ignoredNodesArray_Count;
@dynamic ignoredEdgesArray, ignoredEdgesArray_Count;
@dynamic sourcePubKey;

typedef struct QueryRoutesRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t finalCltvDelta;
  NSString *pubKey;
  FeeLimit *feeLimit;
  NSMutableArray *ignoredNodesArray;
  NSMutableArray *ignoredEdgesArray;
  NSString *sourcePubKey;
  int64_t amt;
} QueryRoutesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_Amt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "finalCltvDelta",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_FinalCltvDelta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, finalCltvDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = GPBStringifySymbol(FeeLimit),
        .number = QueryRoutesRequest_FieldNumber_FeeLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ignoredNodesArray",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_IgnoredNodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, ignoredNodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ignoredEdgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EdgeLocator),
        .number = QueryRoutesRequest_FieldNumber_IgnoredEdgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, ignoredEdgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourcePubKey",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_SourcePubKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, sourcePubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryRoutesRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryRoutesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EdgeLocator

@implementation EdgeLocator

@dynamic channelId;
@dynamic directionReverse;

typedef struct EdgeLocator__storage_ {
  uint32_t _has_storage_[1];
  uint64_t channelId;
} EdgeLocator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = EdgeLocator_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EdgeLocator__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "directionReverse",
        .dataTypeSpecific.className = NULL,
        .number = EdgeLocator_FieldNumber_DirectionReverse,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EdgeLocator class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EdgeLocator__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryRoutesResponse

@implementation QueryRoutesResponse

@dynamic routesArray, routesArray_Count;

typedef struct QueryRoutesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *routesArray;
} QueryRoutesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = QueryRoutesResponse_FieldNumber_RoutesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryRoutesResponse__storage_, routesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryRoutesResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryRoutesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Hop

@implementation Hop

@dynamic chanId;
@dynamic chanCapacity;
@dynamic amtToForward;
@dynamic fee;
@dynamic expiry;
@dynamic amtToForwardMsat;
@dynamic feeMsat;
@dynamic pubKey;

typedef struct Hop__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expiry;
  NSString *pubKey;
  uint64_t chanId;
  int64_t chanCapacity;
  int64_t amtToForward;
  int64_t fee;
  int64_t amtToForwardMsat;
  int64_t feeMsat;
} Hop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Hop__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanCapacity",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_ChanCapacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Hop__storage_, chanCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtToForward",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_AmtToForward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Hop__storage_, amtToForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Hop__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Hop__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "amtToForwardMsat",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_AmtToForwardMsat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Hop__storage_, amtToForwardMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeMsat",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_FeeMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Hop__storage_, feeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_PubKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Hop__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Hop class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Hop__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Route

@implementation Route

@dynamic totalTimeLock;
@dynamic totalFees;
@dynamic totalAmt;
@dynamic hopsArray, hopsArray_Count;
@dynamic totalFeesMsat;
@dynamic totalAmtMsat;

typedef struct Route__storage_ {
  uint32_t _has_storage_[1];
  uint32_t totalTimeLock;
  NSMutableArray *hopsArray;
  int64_t totalFees;
  int64_t totalAmt;
  int64_t totalFeesMsat;
  int64_t totalAmtMsat;
} Route__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalTimeLock",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalTimeLock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Route__storage_, totalTimeLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalFees,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Route__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalAmt",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalAmt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Route__storage_, totalAmt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hopsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Hop),
        .number = Route_FieldNumber_HopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Route__storage_, hopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalFeesMsat",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalFeesMsat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Route__storage_, totalFeesMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalAmtMsat",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalAmtMsat,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Route__storage_, totalAmtMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Route class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Route__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfoRequest

@implementation NodeInfoRequest

@dynamic pubKey;
@dynamic includeChannels;

typedef struct NodeInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} NodeInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfoRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfoRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "includeChannels",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfoRequest_FieldNumber_IncludeChannels,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic hasNode, node;
@dynamic numChannels;
@dynamic totalCapacity;
@dynamic channelsArray, channelsArray_Count;

typedef struct NodeInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numChannels;
  LightningNode *node;
  NSMutableArray *channelsArray;
  int64_t totalCapacity;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningNode),
        .number = NodeInfo_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumChannels,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalCapacity",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_TotalCapacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, totalCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelEdge),
        .number = NodeInfo_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LightningNode

@implementation LightningNode

@dynamic lastUpdate;
@dynamic pubKey;
@dynamic alias;
@dynamic addressesArray, addressesArray_Count;
@dynamic color;

typedef struct LightningNode__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *pubKey;
  NSString *alias;
  NSMutableArray *addressesArray;
  NSString *color;
} LightningNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_LastUpdate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LightningNode__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_PubKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LightningNode__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LightningNode__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeAddress),
        .number = LightningNode_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LightningNode__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_Color,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LightningNode__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LightningNode class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LightningNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeAddress

@implementation NodeAddress

@dynamic network;
@dynamic addr;

typedef struct NodeAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *network;
  NSString *addr;
} NodeAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "network",
        .dataTypeSpecific.className = NULL,
        .number = NodeAddress_FieldNumber_Network,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeAddress__storage_, network),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = NodeAddress_FieldNumber_Addr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeAddress__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeAddress class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoutingPolicy

@implementation RoutingPolicy

@dynamic timeLockDelta;
@dynamic minHtlc;
@dynamic feeBaseMsat;
@dynamic feeRateMilliMsat;
@dynamic disabled;
@dynamic maxHtlcMsat;

typedef struct RoutingPolicy__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeLockDelta;
  int64_t minHtlc;
  int64_t feeBaseMsat;
  int64_t feeRateMilliMsat;
  uint64_t maxHtlcMsat;
} RoutingPolicy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_TimeLockDelta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minHtlc",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_MinHtlc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, minHtlc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeBaseMsat",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_FeeBaseMsat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, feeBaseMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRateMilliMsat",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_FeeRateMilliMsat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, feeRateMilliMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "disabled",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_Disabled,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "maxHtlcMsat",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_MaxHtlcMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, maxHtlcMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoutingPolicy class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoutingPolicy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEdge

@implementation ChannelEdge

@dynamic channelId;
@dynamic chanPoint;
@dynamic lastUpdate;
@dynamic node1Pub;
@dynamic node2Pub;
@dynamic capacity;
@dynamic hasNode1Policy, node1Policy;
@dynamic hasNode2Policy, node2Policy;

typedef struct ChannelEdge__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *chanPoint;
  NSString *node1Pub;
  NSString *node2Pub;
  RoutingPolicy *node1Policy;
  RoutingPolicy *node2Policy;
  uint64_t channelId;
  int64_t capacity;
} ChannelEdge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_LastUpdate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "node1Pub",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Node1Pub,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node1Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "node2Pub",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Node2Pub,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node2Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "node1Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdge_FieldNumber_Node1Policy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node1Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "node2Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdge_FieldNumber_Node2Policy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node2Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEdge class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelEdge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGraphRequest

@implementation ChannelGraphRequest

@dynamic includeUnannounced;

typedef struct ChannelGraphRequest__storage_ {
  uint32_t _has_storage_[1];
} ChannelGraphRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeUnannounced",
        .dataTypeSpecific.className = NULL,
        .number = ChannelGraphRequest_FieldNumber_IncludeUnannounced,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGraphRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelGraphRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGraph

@implementation ChannelGraph

@dynamic nodesArray, nodesArray_Count;
@dynamic edgesArray, edgesArray_Count;

typedef struct ChannelGraph__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodesArray;
  NSMutableArray *edgesArray;
} ChannelGraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningNode),
        .number = ChannelGraph_FieldNumber_NodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelGraph__storage_, nodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelEdge),
        .number = ChannelGraph_FieldNumber_EdgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelGraph__storage_, edgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGraph class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelGraph__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChanInfoRequest

@implementation ChanInfoRequest

@dynamic chanId;

typedef struct ChanInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t chanId;
} ChanInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ChanInfoRequest_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChanInfoRequest__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChanInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChanInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInfoRequest

@implementation NetworkInfoRequest


typedef struct NetworkInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} NetworkInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInfo

@implementation NetworkInfo

@dynamic graphDiameter;
@dynamic avgOutDegree;
@dynamic maxOutDegree;
@dynamic numNodes;
@dynamic numChannels;
@dynamic totalNetworkCapacity;
@dynamic avgChannelSize;
@dynamic minChannelSize;
@dynamic maxChannelSize;
@dynamic medianChannelSizeSat;

typedef struct NetworkInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t graphDiameter;
  uint32_t maxOutDegree;
  uint32_t numNodes;
  uint32_t numChannels;
  double avgOutDegree;
  int64_t totalNetworkCapacity;
  double avgChannelSize;
  int64_t minChannelSize;
  int64_t maxChannelSize;
  int64_t medianChannelSizeSat;
} NetworkInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "graphDiameter",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_GraphDiameter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, graphDiameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avgOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_AvgOutDegree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, avgOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MaxOutDegree,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, maxOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numNodes",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_NumNodes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, numNodes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_NumChannels,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalNetworkCapacity",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_TotalNetworkCapacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, totalNetworkCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "avgChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_AvgChannelSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, avgChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "minChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MinChannelSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, minChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MaxChannelSize,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, maxChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "medianChannelSizeSat",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MedianChannelSizeSat,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, medianChannelSizeSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInfo class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StopRequest

@implementation StopRequest


typedef struct StopRequest__storage_ {
  uint32_t _has_storage_[1];
} StopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(StopRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StopResponse

@implementation StopResponse


typedef struct StopResponse__storage_ {
  uint32_t _has_storage_[1];
} StopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(StopResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GraphTopologySubscription

@implementation GraphTopologySubscription


typedef struct GraphTopologySubscription__storage_ {
  uint32_t _has_storage_[1];
} GraphTopologySubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GraphTopologySubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GraphTopologySubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GraphTopologyUpdate

@implementation GraphTopologyUpdate

@dynamic nodeUpdatesArray, nodeUpdatesArray_Count;
@dynamic channelUpdatesArray, channelUpdatesArray_Count;
@dynamic closedChansArray, closedChansArray_Count;

typedef struct GraphTopologyUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodeUpdatesArray;
  NSMutableArray *channelUpdatesArray;
  NSMutableArray *closedChansArray;
} GraphTopologyUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeUpdate),
        .number = GraphTopologyUpdate_FieldNumber_NodeUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, nodeUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelEdgeUpdate),
        .number = GraphTopologyUpdate_FieldNumber_ChannelUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, channelUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closedChansArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClosedChannelUpdate),
        .number = GraphTopologyUpdate_FieldNumber_ClosedChansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, closedChansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GraphTopologyUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GraphTopologyUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeUpdate

@implementation NodeUpdate

@dynamic addressesArray, addressesArray_Count;
@dynamic identityKey;
@dynamic globalFeatures;
@dynamic alias;
@dynamic color;

typedef struct NodeUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSString *identityKey;
  NSData *globalFeatures;
  NSString *alias;
  NSString *color;
} NodeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityKey",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_IdentityKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, identityKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "globalFeatures",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_GlobalFeatures,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, globalFeatures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_Color,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEdgeUpdate

@implementation ChannelEdgeUpdate

@dynamic chanId;
@dynamic hasChanPoint, chanPoint;
@dynamic capacity;
@dynamic hasRoutingPolicy, routingPolicy;
@dynamic advertisingNode;
@dynamic connectingNode;

typedef struct ChannelEdgeUpdate__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *chanPoint;
  RoutingPolicy *routingPolicy;
  NSString *advertisingNode;
  NSString *connectingNode;
  uint64_t chanId;
  int64_t capacity;
} ChannelEdgeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelEdgeUpdate_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "routingPolicy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdgeUpdate_FieldNumber_RoutingPolicy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, routingPolicy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertisingNode",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_AdvertisingNode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, advertisingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectingNode",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_ConnectingNode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, connectingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEdgeUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelEdgeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClosedChannelUpdate

@implementation ClosedChannelUpdate

@dynamic chanId;
@dynamic capacity;
@dynamic closedHeight;
@dynamic hasChanPoint, chanPoint;

typedef struct ClosedChannelUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t closedHeight;
  ChannelPoint *chanPoint;
  uint64_t chanId;
  int64_t capacity;
} ClosedChannelUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_Capacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closedHeight",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_ClosedHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, closedHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ClosedChannelUpdate_FieldNumber_ChanPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClosedChannelUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClosedChannelUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HopHint

@implementation HopHint

@dynamic nodeId;
@dynamic chanId;
@dynamic feeBaseMsat;
@dynamic feeProportionalMillionths;
@dynamic cltvExpiryDelta;

typedef struct HopHint__storage_ {
  uint32_t _has_storage_[1];
  uint32_t feeBaseMsat;
  uint32_t feeProportionalMillionths;
  uint32_t cltvExpiryDelta;
  NSString *nodeId;
  uint64_t chanId;
} HopHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeId",
        .dataTypeSpecific.className = NULL,
        .number = HopHint_FieldNumber_NodeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HopHint__storage_, nodeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = HopHint_FieldNumber_ChanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HopHint__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "feeBaseMsat",
        .dataTypeSpecific.className = NULL,
        .number = HopHint_FieldNumber_FeeBaseMsat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HopHint__storage_, feeBaseMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "feeProportionalMillionths",
        .dataTypeSpecific.className = NULL,
        .number = HopHint_FieldNumber_FeeProportionalMillionths,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HopHint__storage_, feeProportionalMillionths),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cltvExpiryDelta",
        .dataTypeSpecific.className = NULL,
        .number = HopHint_FieldNumber_CltvExpiryDelta,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HopHint__storage_, cltvExpiryDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HopHint class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HopHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RouteHint

@implementation RouteHint

@dynamic hopHintsArray, hopHintsArray_Count;

typedef struct RouteHint__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hopHintsArray;
} RouteHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hopHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(HopHint),
        .number = RouteHint_FieldNumber_HopHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RouteHint__storage_, hopHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RouteHint class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RouteHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Invoice

@implementation Invoice

@dynamic memo;
@dynamic receipt;
@dynamic rPreimage;
@dynamic rHash;
@dynamic value;
@dynamic settled;
@dynamic creationDate;
@dynamic settleDate;
@dynamic paymentRequest;
@dynamic descriptionHash;
@dynamic expiry;
@dynamic fallbackAddr;
@dynamic cltvExpiry;
@dynamic routeHintsArray, routeHintsArray_Count;
@dynamic private_p;
@dynamic addIndex;
@dynamic settleIndex;
@dynamic amtPaid;
@dynamic amtPaidSat;
@dynamic amtPaidMsat;
@dynamic state;

typedef struct Invoice__storage_ {
  uint32_t _has_storage_[1];
  Invoice_InvoiceState state;
  NSString *memo;
  NSData *receipt;
  NSData *rPreimage;
  NSData *rHash;
  NSString *paymentRequest;
  NSData *descriptionHash;
  NSString *fallbackAddr;
  NSMutableArray *routeHintsArray;
  int64_t value;
  int64_t creationDate;
  int64_t settleDate;
  int64_t expiry;
  uint64_t cltvExpiry;
  uint64_t addIndex;
  uint64_t settleIndex;
  int64_t amtPaid;
  int64_t amtPaidSat;
  int64_t amtPaidMsat;
} Invoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memo",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Memo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Invoice__storage_, memo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Receipt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Invoice__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rPreimage",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_RPreimage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Invoice__storage_, rPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_RHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Invoice__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Invoice__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settled",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Settled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_CreationDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Invoice__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settleDate",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_SettleDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Invoice__storage_, settleDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_PaymentRequest,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Invoice__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_DescriptionHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Invoice__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Expiry,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Invoice__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_FallbackAddr,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Invoice__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_CltvExpiry,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Invoice__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "routeHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RouteHint),
        .number = Invoice_FieldNumber_RouteHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Invoice__storage_, routeHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Private_p,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_AddIndex,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Invoice__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "settleIndex",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_SettleIndex,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Invoice__storage_, settleIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtPaid",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_AmtPaid,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Invoice__storage_, amtPaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtPaidSat",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_AmtPaidSat,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Invoice__storage_, amtPaidSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtPaidMsat",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_AmtPaidMsat,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Invoice__storage_, amtPaidMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = Invoice_InvoiceState_EnumDescriptor,
        .number = Invoice_FieldNumber_State,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(Invoice__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Invoice class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Invoice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Invoice_State_RawValue(Invoice *message) {
  GPBDescriptor *descriptor = [Invoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Invoice_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetInvoice_State_RawValue(Invoice *message, int32_t value) {
  GPBDescriptor *descriptor = [Invoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Invoice_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Invoice_InvoiceState

GPBEnumDescriptor *Invoice_InvoiceState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Settled\000Canceled\000Accepted\000";
    static const int32_t values[] = {
        Invoice_InvoiceState_Open,
        Invoice_InvoiceState_Settled,
        Invoice_InvoiceState_Canceled,
        Invoice_InvoiceState_Accepted,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Invoice_InvoiceState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Invoice_InvoiceState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Invoice_InvoiceState_IsValidValue(int32_t value__) {
  switch (value__) {
    case Invoice_InvoiceState_Open:
    case Invoice_InvoiceState_Settled:
    case Invoice_InvoiceState_Canceled:
    case Invoice_InvoiceState_Accepted:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AddInvoiceResponse

@implementation AddInvoiceResponse

@dynamic rHash;
@dynamic paymentRequest;
@dynamic addIndex;

typedef struct AddInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *rHash;
  NSString *paymentRequest;
  uint64_t addIndex;
} AddInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = AddInvoiceResponse_FieldNumber_RHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddInvoiceResponse__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = AddInvoiceResponse_FieldNumber_PaymentRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddInvoiceResponse__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = AddInvoiceResponse_FieldNumber_AddIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddInvoiceResponse__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddInvoiceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentHash

@implementation PaymentHash

@dynamic rHashStr;
@dynamic rHash;

typedef struct PaymentHash__storage_ {
  uint32_t _has_storage_[1];
  NSString *rHashStr;
  NSData *rHash;
} PaymentHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHashStr",
        .dataTypeSpecific.className = NULL,
        .number = PaymentHash_FieldNumber_RHashStr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentHash__storage_, rHashStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = PaymentHash_FieldNumber_RHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentHash__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentHash class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListInvoiceRequest

@implementation ListInvoiceRequest

@dynamic pendingOnly;
@dynamic indexOffset;
@dynamic numMaxInvoices;
@dynamic reversed;

typedef struct ListInvoiceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t indexOffset;
  uint64_t numMaxInvoices;
} ListInvoiceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pendingOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceRequest_FieldNumber_PendingOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "indexOffset",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceRequest_FieldNumber_IndexOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ListInvoiceRequest__storage_, indexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "numMaxInvoices",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceRequest_FieldNumber_NumMaxInvoices,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ListInvoiceRequest__storage_, numMaxInvoices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "reversed",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceRequest_FieldNumber_Reversed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListInvoiceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListInvoiceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListInvoiceResponse

@implementation ListInvoiceResponse

@dynamic invoicesArray, invoicesArray_Count;
@dynamic lastIndexOffset;
@dynamic firstIndexOffset;

typedef struct ListInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *invoicesArray;
  uint64_t lastIndexOffset;
  uint64_t firstIndexOffset;
} ListInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invoicesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Invoice),
        .number = ListInvoiceResponse_FieldNumber_InvoicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListInvoiceResponse__storage_, invoicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastIndexOffset",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceResponse_FieldNumber_LastIndexOffset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListInvoiceResponse__storage_, lastIndexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "firstIndexOffset",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceResponse_FieldNumber_FirstIndexOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ListInvoiceResponse__storage_, firstIndexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListInvoiceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvoiceSubscription

@implementation InvoiceSubscription

@dynamic addIndex;
@dynamic settleIndex;

typedef struct InvoiceSubscription__storage_ {
  uint32_t _has_storage_[1];
  uint64_t addIndex;
  uint64_t settleIndex;
} InvoiceSubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = InvoiceSubscription_FieldNumber_AddIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvoiceSubscription__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "settleIndex",
        .dataTypeSpecific.className = NULL,
        .number = InvoiceSubscription_FieldNumber_SettleIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvoiceSubscription__storage_, settleIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvoiceSubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvoiceSubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Payment

@implementation Payment

@dynamic paymentHash;
@dynamic value;
@dynamic creationDate;
@dynamic pathArray, pathArray_Count;
@dynamic fee;
@dynamic paymentPreimage;
@dynamic valueSat;
@dynamic valueMsat;
@dynamic paymentRequest;
@dynamic status;

typedef struct Payment__storage_ {
  uint32_t _has_storage_[1];
  Payment_PaymentStatus status;
  NSString *paymentHash;
  NSMutableArray *pathArray;
  NSString *paymentPreimage;
  NSString *paymentRequest;
  int64_t value;
  int64_t creationDate;
  int64_t fee;
  int64_t valueSat;
  int64_t valueMsat;
} Payment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PaymentHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Payment__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Payment__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_CreationDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Payment__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Payment__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Payment__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PaymentPreimage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Payment__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valueSat",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_ValueSat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Payment__storage_, valueSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "valueMsat",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_ValueMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Payment__storage_, valueMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PaymentRequest,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Payment__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Payment_PaymentStatus_EnumDescriptor,
        .number = Payment_FieldNumber_Status,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Payment__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Payment class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Payment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Payment_Status_RawValue(Payment *message) {
  GPBDescriptor *descriptor = [Payment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Payment_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPayment_Status_RawValue(Payment *message, int32_t value) {
  GPBDescriptor *descriptor = [Payment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Payment_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Payment_PaymentStatus

GPBEnumDescriptor *Payment_PaymentStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000InFlight\000Succeeded\000Failed\000";
    static const int32_t values[] = {
        Payment_PaymentStatus_Unknown,
        Payment_PaymentStatus_InFlight,
        Payment_PaymentStatus_Succeeded,
        Payment_PaymentStatus_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Payment_PaymentStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Payment_PaymentStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Payment_PaymentStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case Payment_PaymentStatus_Unknown:
    case Payment_PaymentStatus_InFlight:
    case Payment_PaymentStatus_Succeeded:
    case Payment_PaymentStatus_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ListPaymentsRequest

@implementation ListPaymentsRequest

@dynamic includeIncomplete;

typedef struct ListPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} ListPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeIncomplete",
        .dataTypeSpecific.className = NULL,
        .number = ListPaymentsRequest_FieldNumber_IncludeIncomplete,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPaymentsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPaymentsResponse

@implementation ListPaymentsResponse

@dynamic paymentsArray, paymentsArray_Count;

typedef struct ListPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *paymentsArray;
} ListPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Payment),
        .number = ListPaymentsResponse_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListPaymentsResponse__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPaymentsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAllPaymentsRequest

@implementation DeleteAllPaymentsRequest


typedef struct DeleteAllPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} DeleteAllPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAllPaymentsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteAllPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAllPaymentsResponse

@implementation DeleteAllPaymentsResponse


typedef struct DeleteAllPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
} DeleteAllPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAllPaymentsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteAllPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AbandonChannelRequest

@implementation AbandonChannelRequest

@dynamic hasChannelPoint, channelPoint;

typedef struct AbandonChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *channelPoint;
} AbandonChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = AbandonChannelRequest_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AbandonChannelRequest__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AbandonChannelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AbandonChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AbandonChannelResponse

@implementation AbandonChannelResponse


typedef struct AbandonChannelResponse__storage_ {
  uint32_t _has_storage_[1];
} AbandonChannelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AbandonChannelResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AbandonChannelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DebugLevelRequest

@implementation DebugLevelRequest

@dynamic show;
@dynamic levelSpec;

typedef struct DebugLevelRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *levelSpec;
} DebugLevelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "show",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelRequest_FieldNumber_Show,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "levelSpec",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelRequest_FieldNumber_LevelSpec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DebugLevelRequest__storage_, levelSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebugLevelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebugLevelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DebugLevelResponse

@implementation DebugLevelResponse

@dynamic subSystems;

typedef struct DebugLevelResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *subSystems;
} DebugLevelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subSystems",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelResponse_FieldNumber_SubSystems,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DebugLevelResponse__storage_, subSystems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebugLevelResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebugLevelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayReqString

@implementation PayReqString

@dynamic payReq;

typedef struct PayReqString__storage_ {
  uint32_t _has_storage_[1];
  NSString *payReq;
} PayReqString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payReq",
        .dataTypeSpecific.className = NULL,
        .number = PayReqString_FieldNumber_PayReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayReqString__storage_, payReq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayReqString class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayReqString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayReq

@implementation PayReq

@dynamic destination;
@dynamic paymentHash;
@dynamic numSatoshis;
@dynamic timestamp;
@dynamic expiry;
@dynamic description_p;
@dynamic descriptionHash;
@dynamic fallbackAddr;
@dynamic cltvExpiry;
@dynamic routeHintsArray, routeHintsArray_Count;

typedef struct PayReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *destination;
  NSString *paymentHash;
  NSString *description_p;
  NSString *descriptionHash;
  NSString *fallbackAddr;
  NSMutableArray *routeHintsArray;
  int64_t numSatoshis;
  int64_t timestamp;
  int64_t expiry;
  int64_t cltvExpiry;
} PayReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Destination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayReq__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_PaymentHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PayReq__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numSatoshis",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_NumSatoshis,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PayReq__storage_, numSatoshis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PayReq__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PayReq__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PayReq__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_DescriptionHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PayReq__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_FallbackAddr,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PayReq__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_CltvExpiry,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PayReq__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "routeHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RouteHint),
        .number = PayReq_FieldNumber_RouteHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PayReq__storage_, routeHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayReq class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeReportRequest

@implementation FeeReportRequest


typedef struct FeeReportRequest__storage_ {
  uint32_t _has_storage_[1];
} FeeReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeReportRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(FeeReportRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelFeeReport

@implementation ChannelFeeReport

@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feePerMil;
@dynamic feeRate;

typedef struct ChannelFeeReport__storage_ {
  uint32_t _has_storage_[1];
  NSString *chanPoint;
  int64_t baseFeeMsat;
  int64_t feePerMil;
  double feeRate;
} ChannelFeeReport__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_ChanPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerMil",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_FeePerMil,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, feePerMil),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_FeeRate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelFeeReport class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelFeeReport__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeReportResponse

@implementation FeeReportResponse

@dynamic channelFeesArray, channelFeesArray_Count;
@dynamic dayFeeSum;
@dynamic weekFeeSum;
@dynamic monthFeeSum;

typedef struct FeeReportResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelFeesArray;
  uint64_t dayFeeSum;
  uint64_t weekFeeSum;
  uint64_t monthFeeSum;
} FeeReportResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelFeesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelFeeReport),
        .number = FeeReportResponse_FieldNumber_ChannelFeesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, channelFeesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dayFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_DayFeeSum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, dayFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "weekFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_WeekFeeSum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, weekFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "monthFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_MonthFeeSum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, monthFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeReportResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeeReportResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PolicyUpdateRequest

@implementation PolicyUpdateRequest

@dynamic scopeOneOfCase;
@dynamic global;
@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feeRate;
@dynamic timeLockDelta;

typedef struct PolicyUpdateRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t timeLockDelta;
  ChannelPoint *chanPoint;
  int64_t baseFeeMsat;
  double feeRate;
} PolicyUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "global",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_Global,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = PolicyUpdateRequest_FieldNumber_ChanPoint,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_FeeRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_TimeLockDelta,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PolicyUpdateRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PolicyUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "scope",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void PolicyUpdateRequest_ClearScopeOneOfCase(PolicyUpdateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PolicyUpdateResponse

@implementation PolicyUpdateResponse


typedef struct PolicyUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
} PolicyUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PolicyUpdateResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PolicyUpdateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingHistoryRequest

@implementation ForwardingHistoryRequest

@dynamic startTime;
@dynamic endTime;
@dynamic indexOffset;
@dynamic numMaxEvents;

typedef struct ForwardingHistoryRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t indexOffset;
  uint32_t numMaxEvents;
  uint64_t startTime;
  uint64_t endTime;
} ForwardingHistoryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "indexOffset",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_IndexOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, indexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numMaxEvents",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_NumMaxEvents,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, numMaxEvents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingHistoryRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingHistoryRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingEvent

@implementation ForwardingEvent

@dynamic timestamp;
@dynamic chanIdIn;
@dynamic chanIdOut;
@dynamic amtIn;
@dynamic amtOut;
@dynamic fee;
@dynamic feeMsat;

typedef struct ForwardingEvent__storage_ {
  uint32_t _has_storage_[1];
  uint64_t timestamp;
  uint64_t chanIdIn;
  uint64_t chanIdOut;
  uint64_t amtIn;
  uint64_t amtOut;
  uint64_t fee;
  uint64_t feeMsat;
} ForwardingEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdIn",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_ChanIdIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, chanIdIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdOut",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_ChanIdOut,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, chanIdOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtIn",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_AmtIn,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, amtIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtOut",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_AmtOut,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, amtOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_Fee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "feeMsat",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_FeeMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, feeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingEvent class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingHistoryResponse

@implementation ForwardingHistoryResponse

@dynamic forwardingEventsArray, forwardingEventsArray_Count;
@dynamic lastOffsetIndex;

typedef struct ForwardingHistoryResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastOffsetIndex;
  NSMutableArray *forwardingEventsArray;
} ForwardingHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "forwardingEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ForwardingEvent),
        .number = ForwardingHistoryResponse_FieldNumber_ForwardingEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ForwardingHistoryResponse__storage_, forwardingEventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastOffsetIndex",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryResponse_FieldNumber_LastOffsetIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingHistoryResponse__storage_, lastOffsetIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingHistoryResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingHistoryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExportChannelBackupRequest

@implementation ExportChannelBackupRequest

@dynamic hasChanPoint, chanPoint;

typedef struct ExportChannelBackupRequest__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *chanPoint;
} ExportChannelBackupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ExportChannelBackupRequest_FieldNumber_ChanPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExportChannelBackupRequest__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExportChannelBackupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExportChannelBackupRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBackup

@implementation ChannelBackup

@dynamic hasChanPoint, chanPoint;
@dynamic chanBackup;

typedef struct ChannelBackup__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *chanPoint;
  NSData *chanBackup;
} ChannelBackup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelBackup_FieldNumber_ChanPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelBackup__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanBackup",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBackup_FieldNumber_ChanBackup,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelBackup__storage_, chanBackup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBackup class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelBackup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiChanBackup

@implementation MultiChanBackup

@dynamic chanPointsArray, chanPointsArray_Count;
@dynamic multiChanBackup;

typedef struct MultiChanBackup__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chanPointsArray;
  NSData *multiChanBackup;
} MultiChanBackup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPointsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = MultiChanBackup_FieldNumber_ChanPointsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiChanBackup__storage_, chanPointsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiChanBackup",
        .dataTypeSpecific.className = NULL,
        .number = MultiChanBackup_FieldNumber_MultiChanBackup,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiChanBackup__storage_, multiChanBackup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiChanBackup class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiChanBackup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChanBackupExportRequest

@implementation ChanBackupExportRequest


typedef struct ChanBackupExportRequest__storage_ {
  uint32_t _has_storage_[1];
} ChanBackupExportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChanBackupExportRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChanBackupExportRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChanBackupSnapshot

@implementation ChanBackupSnapshot

@dynamic hasSingleChanBackups, singleChanBackups;
@dynamic hasMultiChanBackup, multiChanBackup;

typedef struct ChanBackupSnapshot__storage_ {
  uint32_t _has_storage_[1];
  ChannelBackups *singleChanBackups;
  MultiChanBackup *multiChanBackup;
} ChanBackupSnapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "singleChanBackups",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelBackups),
        .number = ChanBackupSnapshot_FieldNumber_SingleChanBackups,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChanBackupSnapshot__storage_, singleChanBackups),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiChanBackup",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiChanBackup),
        .number = ChanBackupSnapshot_FieldNumber_MultiChanBackup,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChanBackupSnapshot__storage_, multiChanBackup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChanBackupSnapshot class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChanBackupSnapshot__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBackups

@implementation ChannelBackups

@dynamic chanBackupsArray, chanBackupsArray_Count;

typedef struct ChannelBackups__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chanBackupsArray;
} ChannelBackups__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanBackupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelBackup),
        .number = ChannelBackups_FieldNumber_ChanBackupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelBackups__storage_, chanBackupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBackups class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelBackups__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RestoreChanBackupRequest

@implementation RestoreChanBackupRequest

@dynamic backupOneOfCase;
@dynamic chanBackups;
@dynamic multiChanBackup;

typedef struct RestoreChanBackupRequest__storage_ {
  uint32_t _has_storage_[2];
  ChannelBackups *chanBackups;
  NSData *multiChanBackup;
} RestoreChanBackupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanBackups",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelBackups),
        .number = RestoreChanBackupRequest_FieldNumber_ChanBackups,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RestoreChanBackupRequest__storage_, chanBackups),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiChanBackup",
        .dataTypeSpecific.className = NULL,
        .number = RestoreChanBackupRequest_FieldNumber_MultiChanBackup,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RestoreChanBackupRequest__storage_, multiChanBackup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RestoreChanBackupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RestoreChanBackupRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "backup",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void RestoreChanBackupRequest_ClearBackupOneOfCase(RestoreChanBackupRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - RestoreBackupResponse

@implementation RestoreBackupResponse


typedef struct RestoreBackupResponse__storage_ {
  uint32_t _has_storage_[1];
} RestoreBackupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RestoreBackupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RestoreBackupResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBackupSubscription

@implementation ChannelBackupSubscription


typedef struct ChannelBackupSubscription__storage_ {
  uint32_t _has_storage_[1];
} ChannelBackupSubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBackupSubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChannelBackupSubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyChanBackupResponse

@implementation VerifyChanBackupResponse


typedef struct VerifyChanBackupResponse__storage_ {
  uint32_t _has_storage_[1];
} VerifyChanBackupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyChanBackupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(VerifyChanBackupResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
